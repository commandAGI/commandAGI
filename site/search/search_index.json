{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to CommandLAB","text":"<p>CommandLAB is a powerful framework for automating and controlling computers across different environments. It provides a unified interface for interacting with local and remote computers, making it easy to build automation tools, test applications, and train AI agents.</p> <p></p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Unified Computer Control API: Control any computer with the same code, regardless of platform or location</li> <li>Multiple Deployment Options: Run locally, in containers, or in various cloud environments</li> <li>Reinforcement Learning Framework: Train and evaluate AI agents to use computers through a standardized gym interface</li> <li>Modular Architecture: Easily extend with new computer implementations, provisioners, or agent types</li> <li>Cross-Platform Support: Works on Windows, macOS, and Linux</li> <li>Cloud Integration: Native support for AWS, Azure, and Google Cloud Platform</li> <li>Container Support: Docker and Kubernetes integration for scalable deployments</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install commandlab\n</code></pre>"},{"location":"#optional-components","title":"Optional Components","text":"<p>CommandLAB uses a modular design with optional components that can be installed based on your needs:</p> Component Description Installation Local control Control your local computer <code>pip install \"commandlab[local]\"</code> VNC support Control computers via VNC <code>pip install \"commandlab[vnc]\"</code> Docker support Run in Docker containers <code>pip install \"commandlab[docker]\"</code> Kubernetes support Deploy in Kubernetes <code>pip install \"commandlab[kubernetes]\"</code> Cloud providers AWS, Azure, GCP integration <code>pip install \"commandlab[cloud]\"</code> Daemon Remote control server <code>pip install \"commandlab[daemon]\"</code> E2B Desktop E2B Desktop integration <code>pip install \"commandlab[e2b-desktop]\"</code> Scrapybara Scrapybara integration <code>pip install \"commandlab[scrapybara]\"</code> LangChain LangChain integration <code>pip install \"commandlab[langchain]\"</code> PIG PIG integration <code>pip install \"commandlab[pig]\"</code> OCR Pytesseract OCR <code>pip install \"commandlab[pytesseract]\"</code> Development Tools for contributing <code>pip install \"commandlab[dev]\"</code> All features Everything included <code>pip install \"commandlab[all]\"</code>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from commandLAB.computers.local_pynput_computer import LocalPynputComputer\nfrom commandLAB.types import ClickAction, TypeAction\n\n# Create a computer instance\ncomputer = LocalPynputComputer()\n\n# Take a screenshot\nscreenshot = computer.get_screenshot()\n\n# Click at coordinates (100, 100)\ncomputer.execute_click(ClickAction(x=100, y=100))\n\n# Type text\ncomputer.execute_type(TypeAction(text=\"Hello, CommandLAB!\"))\n</code></pre>"},{"location":"#remote-control-example","title":"Remote Control Example","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\n# Create a computer with Docker provisioning\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER\n)\n\n# Execute a command in the container\ncomputer.execute_command(CommandAction(command=\"ls -la\", timeout=5))\n\n# Clean up when done\ncomputer.close()\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation Guide - Detailed installation instructions</li> <li>Quick Start Guide - Get up and running quickly</li> <li>Core Concepts - Learn about the fundamental concepts</li> <li>Computers - Computer implementations</li> <li>Provisioners - Environment management</li> <li>Gym Framework - Reinforcement learning</li> <li>Daemon - Remote control</li> <li>Types - Data models</li> <li>Tutorials - Step-by-step guides</li> <li>Getting Started - Basic tutorials</li> <li>Advanced - Advanced topics</li> <li>Examples - Real-world examples</li> <li>API Reference - Detailed API documentation</li> <li>Developer Guide - Contributing to CommandLAB</li> </ul>"},{"location":"#who-is-commandlab-for","title":"Who is CommandLAB for?","text":"<ul> <li>Automation Engineers: Create robust automation scripts that work across different environments</li> <li>AI Researchers: Train and evaluate computer-using agents with a standardized interface</li> <li>DevOps Teams: Automate testing and deployment across different platforms</li> <li>Python Developers: Build tools that interact with computer UIs in a consistent way</li> <li>QA Engineers: Create automated tests for GUI applications</li> </ul>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>GitHub Repository - Source code and issue tracking</li> <li>Documentation - Online documentation</li> <li>Discord Community - Community support and discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>CommandLAB is released under the MIT License. See the LICENSE file for details.</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide provides detailed instructions for installing CommandLAB and its dependencies on different operating systems.</p>"},{"location":"installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: Python 3.9 or higher</li> <li>Operating System:</li> <li>Windows 10 or higher</li> <li>macOS 10.14 (Mojave) or higher</li> <li>Ubuntu 18.04 or higher, or other Linux distributions with X11</li> <li>Hardware:</li> <li>Recommended: 2GB RAM, 1GHz CPU</li> <li>Permissions:</li> <li>Local control requires permissions to simulate keyboard and mouse input</li> <li>Docker support requires Docker installed and running</li> <li>Cloud deployments require appropriate cloud provider credentials</li> </ul>"},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<p>The simplest way to install CommandLAB is using pip:</p> <pre><code>pip install commandlab\n</code></pre> <p>This installs the core framework without specific backends. You'll need to install additional components based on your use case.</p>"},{"location":"installation/#installation-with-backends","title":"Installation with Backends","text":""},{"location":"installation/#local-computer-control","title":"Local Computer Control","text":"<p>To control your local computer, install the local backend:</p> <pre><code>pip install \"commandlab[local]\"\n</code></pre> <p>This installs dependencies for controlling your local computer: - <code>pynput</code> for keyboard and mouse control - <code>pyautogui</code> for alternative input control - <code>mss</code> for fast screenshots</p>"},{"location":"installation/#platform-specific-notes","title":"Platform-Specific Notes","text":"<p>Windows: - No additional requirements</p> <p>macOS: - You may need to grant accessibility permissions to your terminal or Python application - Go to System Preferences &gt; Security &amp; Privacy &gt; Privacy &gt; Accessibility and add your terminal application</p> <p>Linux: - X11 is required for input control - Install X11 dependencies: <code>sudo apt-get install python3-xlib python3-tk python3-dev</code></p>"},{"location":"installation/#remote-daemon","title":"Remote Daemon","text":"<p>To use the remote control daemon:</p> <pre><code>pip install \"commandlab[daemon]\"\n</code></pre> <p>This installs: - <code>fastapi</code> and <code>uvicorn</code> for the API server - <code>requests</code> for client communication</p>"},{"location":"installation/#container-support","title":"Container Support","text":"<p>For Docker container support:</p> <pre><code>pip install \"commandlab[docker]\"\n</code></pre> <p>This requires: - Docker installed and running on your system - Python Docker SDK</p> <p>For Kubernetes support:</p> <pre><code>pip install \"commandlab[kubernetes]\"\n</code></pre> <p>This requires: - <code>kubernetes</code> Python client - <code>kubectl</code> configured with access to a cluster</p>"},{"location":"installation/#cloud-provider-support","title":"Cloud Provider Support","text":"<p>For AWS support:</p> <pre><code>pip install \"commandlab[aws]\"\n</code></pre> <p>For Azure support:</p> <pre><code>pip install \"commandlab[azure]\"\n</code></pre> <p>For Google Cloud Platform support:</p> <pre><code>pip install \"commandlab[gcp]\"\n</code></pre> <p>For all cloud providers:</p> <pre><code>pip install \"commandlab[cloud]\"\n</code></pre>"},{"location":"installation/#integration-components","title":"Integration Components","text":"<p>For OCR capabilities:</p> <pre><code>pip install \"commandlab[pytesseract]\"\n</code></pre> <p>This requires: - Tesseract OCR installed on your system   - Windows: Download from GitHub   - macOS: <code>brew install tesseract</code>   - Linux: <code>sudo apt-get install tesseract-ocr</code></p> <p>For E2B Desktop integration:</p> <pre><code>pip install \"commandlab[e2b-desktop]\"\n</code></pre> <p>For LangChain integration:</p> <pre><code>pip install \"commandlab[langchain]\"\n</code></pre>"},{"location":"installation/#all-features","title":"All Features","text":"<p>To install all available backends and features:</p> <pre><code>pip install \"commandlab[all]\"\n</code></pre> <p>Note that this will install all dependencies, which may include conflicting packages. It's generally better to install only the components you need.</p>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributing to CommandLAB:</p> <pre><code># Clone the repository\ngit clone https://github.com/your-org/commandlab.git\ncd commandlab\n\n# Install in development mode with development dependencies\npip install -e \".[dev]\"\n\n# Run tests\npytest\n</code></pre>"},{"location":"installation/#virtual-environment","title":"Virtual Environment","text":"<p>It's recommended to install CommandLAB in a virtual environment:</p> <pre><code># Create a virtual environment\npython -m venv commandlab-env\n\n# Activate the environment\n# On Windows:\ncommandlab-env\\Scripts\\activate\n# On macOS/Linux:\nsource commandlab-env/bin/activate\n\n# Install CommandLAB\npip install \"commandlab[local,daemon]\"\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#permission-errors","title":"Permission Errors","text":"<p>Problem: <code>PermissionError</code> when trying to control mouse or keyboard</p> <p>Solution: - Run your script with administrator/root privileges - On macOS, grant accessibility permissions to your terminal - On Linux, ensure you have the necessary X11 permissions</p>"},{"location":"installation/#import-errors","title":"Import Errors","text":"<p>Problem: <code>ImportError: No module named 'pynput'</code> or similar</p> <p>Solution: - Ensure you've installed the correct extras: <code>pip install \"commandlab[local]\"</code> - Check if your virtual environment is activated</p>"},{"location":"installation/#docker-issues","title":"Docker Issues","text":"<p>Problem: <code>docker.errors.DockerException: Error while fetching server API version</code></p> <p>Solution: - Ensure Docker is installed and running - Check if your user has permissions to access Docker</p>"},{"location":"installation/#cloud-provider-authentication","title":"Cloud Provider Authentication","text":"<p>Problem: Authentication errors with cloud providers</p> <p>Solution: - Ensure you've configured credentials:   - AWS: Configure AWS CLI or set environment variables   - Azure: Log in with Azure CLI or set environment variables   - GCP: Set up application default credentials</p>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues not covered here:</p> <ol> <li>Check the GitHub Issues for similar problems</li> <li>Join our Discord community for support</li> <li>Open a new issue with details about your problem</li> </ol>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>To verify your installation:</p> <pre><code>import commandLAB\nprint(f\"CommandLAB version: {commandLAB.__version__}\")\n\n# Test local computer if installed\ntry:\n    from commandLAB.computers.local_pynput_computer import LocalPynputComputer\n    computer = LocalPynputComputer()\n    print(\"Local computer control is working\")\nexcept ImportError:\n    print(\"Local computer control is not installed\")\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Follow the Quick Start Guide to begin using CommandLAB</li> <li>Explore the Core Concepts to understand the framework</li> <li>Try the Basic Automation Tutorial for a hands-on example</li> </ul>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get up and running with CommandLAB quickly. We'll cover the basics of local computer control, remote control via daemon, and using Docker provisioning.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>First, install CommandLAB with the components you need:</p> <pre><code># For local computer control\npip install \"commandlab[local]\"\n\n# For remote control via daemon\npip install \"commandlab[daemon]\"\n\n# For Docker provisioning\npip install \"commandlab[docker]\"\n\n# For all features\npip install \"commandlab[all]\"\n</code></pre>"},{"location":"quickstart/#basic-usage-local-computer-control","title":"Basic Usage: Local Computer Control","text":"<p>The simplest way to use CommandLAB is to control your local computer:</p> <pre><code>from commandLAB.computers.local_pynput_computer import LocalPynputComputer\nfrom commandLAB.types import ClickAction, TypeAction, KeyboardHotkeyAction, KeyboardKey\n\n# Create a computer instance\ncomputer = LocalPynputComputer()\n\n# Take a screenshot\nscreenshot = computer.get_screenshot()\n\n# Click at coordinates (100, 100)\ncomputer.execute_click(ClickAction(x=100, y=100))\n\n# Type text\ncomputer.execute_type(TypeAction(text=\"Hello, CommandLAB!\"))\n\n# Press keyboard shortcut (Ctrl+S)\ncomputer.execute_keyboard_hotkey(KeyboardHotkeyAction(\n    keys=[KeyboardKey.CTRL, KeyboardKey.S]\n))\n</code></pre>"},{"location":"quickstart/#available-actions","title":"Available Actions","text":"<p>CommandLAB provides a rich set of actions for controlling computers:</p> Action Description Example <code>ClickAction</code> Click at specific coordinates <code>ClickAction(x=100, y=200)</code> <code>DoubleClickAction</code> Double-click at coordinates <code>DoubleClickAction(x=100, y=200)</code> <code>TypeAction</code> Type text <code>TypeAction(text=\"Hello\")</code> <code>KeyboardKeyPressAction</code> Press a key <code>KeyboardKeyPressAction(key=KeyboardKey.ENTER)</code> <code>KeyboardHotkeyAction</code> Press a keyboard shortcut <code>KeyboardHotkeyAction(keys=[KeyboardKey.CTRL, KeyboardKey.C])</code> <code>MouseMoveAction</code> Move the mouse <code>MouseMoveAction(x=100, y=200)</code> <code>DragAction</code> Drag from one point to another <code>DragAction(start_x=100, start_y=100, end_x=200, end_y=200)</code> <code>CommandAction</code> Execute a system command <code>CommandAction(command=\"ls -la\", timeout=5)</code>"},{"location":"quickstart/#getting-observations","title":"Getting Observations","text":"<p>You can also get observations about the computer's state:</p> <pre><code># Get a screenshot\nscreenshot = computer.get_screenshot()\nprint(f\"Screenshot size: {len(screenshot.screenshot)} bytes\")\n\n# Get mouse state\nmouse_state = computer.get_mouse_state()\nprint(f\"Mouse position: {mouse_state.position}\")\nprint(f\"Mouse buttons: {mouse_state.buttons}\")\n\n# Get keyboard state\nkeyboard_state = computer.get_keyboard_state()\nprint(f\"Shift key pressed: {keyboard_state.keys.get(KeyboardKey.SHIFT, False)}\")\n</code></pre>"},{"location":"quickstart/#remote-control-via-daemon","title":"Remote Control via Daemon","text":"<p>CommandLAB allows you to control remote computers using a daemon server:</p>"},{"location":"quickstart/#starting-the-daemon","title":"Starting the Daemon","text":"<p>First, start the daemon on the target computer:</p> <pre><code># Start the daemon on port 8000 using the pynput backend\npython -m commandLAB.daemon.cli start --port 8000 --backend pynput\n</code></pre> <p>The daemon will print an API token that you'll need to connect to it.</p>"},{"location":"quickstart/#connecting-to-the-daemon","title":"Connecting to the Daemon","text":"<p>Then, control it from another machine:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.types import TypeAction, ClickAction\n\n# Connect to the daemon manually\ncomputer = DaemonClientComputer(\n    daemon_base_url=\"http://target-machine-ip\",\n    daemon_port=8000,\n    provisioning_method=ProvisioningMethod.MANUAL\n)\n\n# Take a screenshot of the remote computer\nscreenshot = computer.get_screenshot()\n\n# Click at coordinates (100, 100) on the remote computer\ncomputer.execute_click(ClickAction(x=100, y=100))\n\n# Type text on the remote computer\ncomputer.execute_type(TypeAction(text=\"Hello from another machine!\"))\n\n# Clean up when done\ncomputer.close()\n</code></pre>"},{"location":"quickstart/#using-docker-provisioning","title":"Using Docker Provisioning","text":"<p>CommandLAB can automatically provision and manage Docker containers:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.types import CommandAction, TypeAction\nfrom commandLAB.computers.provisioners.docker_provisioner import DockerPlatform\n\n# Create a computer with Docker provisioning\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER,\n    platform=DockerPlatform.LOCAL  # Use local Docker\n)\n\n# Execute a command in the container\ncomputer.execute_command(CommandAction(command=\"ls -la\", timeout=5))\n\n# Type text in the container\ncomputer.execute_type(TypeAction(text=\"Hello from Docker!\"))\n\n# Clean up (stops and removes the container)\ncomputer.close()\n</code></pre>"},{"location":"quickstart/#using-cloud-provisioning","title":"Using Cloud Provisioning","text":"<p>CommandLAB supports provisioning computers in various cloud environments:</p>"},{"location":"quickstart/#aws-ec2","title":"AWS EC2","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\n# Create a computer in AWS EC2\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.AWS,\n    region=\"us-west-2\",\n    instance_type=\"t2.micro\"\n)\n\n# Use the computer\n# ...\n\n# Clean up (terminates the EC2 instance)\ncomputer.close()\n</code></pre>"},{"location":"quickstart/#azure-vm","title":"Azure VM","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\n# Create a computer in Azure\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.AZURE,\n    resource_group=\"my-resource-group\",\n    location=\"eastus\"\n)\n\n# Use the computer\n# ...\n\n# Clean up (deletes the Azure VM)\ncomputer.close()\n</code></pre>"},{"location":"quickstart/#google-cloud-platform","title":"Google Cloud Platform","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\n# Create a computer in GCP\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.GCP,\n    project=\"my-project-id\",\n    zone=\"us-central1-a\"\n)\n\n# Use the computer\n# ...\n\n# Clean up (deletes the GCP VM)\ncomputer.close()\n</code></pre>"},{"location":"quickstart/#using-the-gym-framework","title":"Using the Gym Framework","text":"<p>CommandLAB includes a reinforcement learning framework for training agents:</p> <pre><code>from commandLAB.gym.environments.computer_env import ComputerEnv, ComputerEnvConfig\nfrom commandLAB.gym.agents.naive_vision_language_computer_agent import NaiveComputerAgent\nfrom commandLAB.gym.drivers import SimpleDriver\n\n# Configure the environment\nconfig = ComputerEnvConfig(\n    computer_cls_name=\"LocalPynputComputer\"\n)\n\n# Create the environment\nenv = ComputerEnv(config)\n\n# Create an agent\nagent = NaiveComputerAgent(chat_model_options={\n    \"model_provider\": \"openai\",\n    \"model\": \"gpt-4-vision-preview\"\n})\n\n# Create a driver\ndriver = SimpleDriver(env=env, agent=agent)\n\n# Collect an episode\nepisode = driver.collect_episode()\n\n# Print episode statistics\nprint(f\"Episode length: {episode.num_steps}\")\nprint(f\"Total reward: {sum(step.reward for step in episode)}\")\n</code></pre>"},{"location":"quickstart/#complete-example-automating-a-web-search","title":"Complete Example: Automating a Web Search","text":"<p>Here's a complete example that automates opening a browser and performing a web search:</p> <pre><code>import time\nfrom commandLAB.computers.local_pynput_computer import LocalPynputComputer\nfrom commandLAB.types import (\n    CommandAction,\n    TypeAction,\n    ClickAction,\n    KeyboardHotkeyAction,\n    KeyboardKey,\n    KeyboardKeyPressAction\n)\n\n# Create a computer instance\ncomputer = LocalPynputComputer()\n\n# Open a browser (Chrome in this example)\ncomputer.execute_command(CommandAction(command=\"chrome\"))\ntime.sleep(2)  # Wait for the browser to open\n\n# Type a URL\ncomputer.execute_type(TypeAction(text=\"https://www.google.com\"))\ncomputer.execute_keyboard_key_press(KeyboardKeyPressAction(key=KeyboardKey.ENTER))\ntime.sleep(2)  # Wait for the page to load\n\n# Type a search query\ncomputer.execute_type(TypeAction(text=\"CommandLAB python automation\"))\ncomputer.execute_keyboard_key_press(KeyboardKeyPressAction(key=KeyboardKey.ENTER))\ntime.sleep(2)  # Wait for search results\n\n# Take a screenshot of the results\nscreenshot = computer.get_screenshot()\nprint(\"Took screenshot of search results\")\n\n# Close the browser\ncomputer.execute_keyboard_hotkey(KeyboardHotkeyAction(keys=[KeyboardKey.ALT, KeyboardKey.F4]))\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've learned the basics of CommandLAB, you can:</p> <ul> <li>Learn about Core Concepts</li> <li>Explore Computer Types</li> <li>Understand Provisioners</li> <li>Try the Gym Framework</li> <li>Follow the Basic Automation Tutorial</li> <li>Check out the API Reference</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Welcome to the CommandLAB API reference. This section provides detailed documentation for all public APIs in the CommandLAB framework.</p>"},{"location":"api/#core","title":"Core","text":"<ul> <li>BaseComputer - Base class for all computer implementations</li> <li>Types - Data models for actions and observations</li> <li>Utilities - Utility functions and helpers</li> </ul>"},{"location":"api/#computers","title":"Computers","text":"<ul> <li>LocalPynputComputer - Control local computer using pynput</li> <li>LocalPyAutoGUIComputer - Control local computer using PyAutoGUI</li> <li>E2BDesktopComputer - Control E2B Desktop Sandbox</li> <li>DaemonClientComputer - Control remote computers via daemon</li> </ul>"},{"location":"api/#provisioners","title":"Provisioners","text":"<ul> <li>BaseProvisioner - Base class for all provisioners</li> <li>ManualProvisioner - Manual provisioning</li> <li>DockerProvisioner - Docker container provisioning</li> <li>KubernetesProvisioner - Kubernetes provisioning</li> <li>AWSProvisioner - AWS EC2 provisioning</li> <li>AzureProvisioner - Azure VM provisioning</li> <li>GCPProvisioner - Google Cloud Platform provisioning</li> </ul>"},{"location":"api/#daemon","title":"Daemon","text":"<ul> <li>ComputerDaemon - Daemon server for remote control</li> <li>DaemonClient - Client for connecting to the daemon</li> <li>CLI - Command-line interface for the daemon</li> </ul>"},{"location":"api/#gym-framework","title":"Gym Framework","text":"<ul> <li>BaseEnv - Base class for environments</li> <li>MultiModalEnv - Environment with multiple modalities</li> <li>ComputerEnv - Environment for computer control</li> <li>BaseAgent - Base class for agents</li> <li>NaiveComputerAgent - Simple vision-language agent</li> <li>ReactComputerAgent - Agent using the ReAct framework</li> <li>BaseDriver - Base class for drivers</li> <li>SimpleDriver - Single-threaded sequential driver</li> <li>ThreadedDriver - Multi-threaded driver</li> <li>MultiprocessDriver - Multi-process driver</li> <li>BaseTrainer - Base class for trainers</li> <li>OnlineTrainer - Trainer that trains after each episode</li> <li>OfflineTrainer - Trainer that trains after collecting all episodes</li> <li>BatchTrainer - Trainer that trains in batches</li> </ul>"},{"location":"api/#processors","title":"Processors","text":"<ul> <li>ScreenParser - Parse text from screenshots</li> <li>GridOverlay - Overlay a grid on screenshots</li> <li>AudioTranscription - Transcribe audio to text</li> <li>TextToSpeech - Convert text to speech</li> </ul>"},{"location":"api/#utilities","title":"Utilities","text":"<ul> <li>Image - Image processing utilities</li> <li>Viewer - GUI viewer for environments</li> </ul>"},{"location":"api/#using-the-api","title":"Using the API","text":""},{"location":"api/#basic-usage-pattern","title":"Basic Usage Pattern","text":"<p>Most CommandLAB APIs follow a consistent pattern:</p> <pre><code># Import the necessary classes\nfrom commandLAB.computers.local_pynput_computer import LocalPynputComputer\nfrom commandLAB.types import ClickAction, TypeAction\n\n# Create an instance\ncomputer = LocalPynputComputer()\n\n# Use the instance\ncomputer.execute_click(ClickAction(x=100, y=100))\ncomputer.execute_type(TypeAction(text=\"Hello, CommandLAB!\"))\n\n# Clean up\ncomputer.close()\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>CommandLAB APIs use exceptions to indicate errors:</p> <pre><code>try:\n    computer = LocalPynputComputer()\n    computer.execute_click(ClickAction(x=100, y=100))\nexcept Exception as e:\n    print(f\"Error: {e}\")\nfinally:\n    computer.close()\n</code></pre>"},{"location":"api/#async-support","title":"Async Support","text":"<p>Some CommandLAB APIs support async/await:</p> <pre><code>import asyncio\nfrom commandLAB.daemon.async_client import AsyncDaemonClient\n\nasync def main():\n    client = AsyncDaemonClient(\"http://localhost:8000\")\n    try:\n        screenshot = await client.get_screenshot()\n        await client.execute_click(ClickAction(x=100, y=100))\n    finally:\n        await client.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/#api-stability","title":"API Stability","text":"<p>CommandLAB follows semantic versioning:</p> <ul> <li>Stable APIs: Classes and methods in the public API without a leading underscore</li> <li>Internal APIs: Classes and methods with a leading underscore (e.g., <code>_internal_method</code>)</li> <li>Experimental APIs: Classes and methods in modules named <code>experimental</code></li> </ul>"},{"location":"api/#api-versioning","title":"API Versioning","text":"<p>CommandLAB uses the following versioning scheme:</p> <ul> <li>Major version: Breaking changes to the API</li> <li>Minor version: New features without breaking changes</li> <li>Patch version: Bug fixes without breaking changes</li> </ul>"},{"location":"api/#api-deprecation","title":"API Deprecation","text":"<p>When an API is deprecated:</p> <ol> <li>It is marked with a <code>@deprecated</code> decorator</li> <li>A warning is issued when the API is used</li> <li>The API continues to work for at least one major version</li> <li>The API is removed in the next major version</li> </ol>"},{"location":"api/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts - Learn about the fundamental concepts</li> <li>Tutorials - Step-by-step guides</li> <li>Guides - How-to guides for specific tasks </li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":"<p>CommandLAB is built around several key concepts that work together to provide a flexible and powerful framework for computer automation. This section explains these concepts in detail and how they interact with each other.</p> <p></p>"},{"location":"concepts/#overview","title":"Overview","text":"<p>CommandLAB's architecture is designed to be modular, extensible, and cloud-ready. The key components are:</p> <ol> <li>Computers: The core interfaces for controlling computers</li> <li>Provisioners: Tools for setting up and managing computer environments</li> <li>Gym Framework: A reinforcement learning framework for training agents</li> <li>Daemon: A service for remote computer control</li> <li>Types: The data models that define actions and observations</li> </ol>"},{"location":"concepts/#computers","title":"Computers","text":"<p>Computers are the central abstraction in CommandLAB. A Computer represents any system that can be controlled programmatically, whether it's your local machine, a remote server, or a virtual environment.</p> <p>All computers implement the <code>BaseComputer</code> interface, which provides methods for:</p> <ul> <li>Taking screenshots</li> <li>Getting mouse and keyboard state</li> <li>Executing commands</li> <li>Controlling the mouse and keyboard</li> </ul> <p>Available computer implementations include:</p> <ul> <li><code>LocalPynputComputer</code>: Controls your local computer using pynput</li> <li><code>LocalPyAutoGUIComputer</code>: Controls your local computer using PyAutoGUI</li> <li><code>E2BDesktopComputer</code>: Uses E2B Desktop Sandbox for secure interactions</li> <li><code>DaemonClientComputer</code>: Connects to a remote daemon for computer control</li> </ul>"},{"location":"concepts/#provisioners","title":"Provisioners","text":"<p>Provisioners handle the setup, management, and teardown of computer environments. They're especially useful for cloud and container deployments.</p> <p>A provisioner is responsible for:</p> <ol> <li>Setting up a computer environment (e.g., starting a Docker container)</li> <li>Checking if the environment is running</li> <li>Tearing down the environment when it's no longer needed</li> </ol> <p>Available provisioner implementations include:</p> <ul> <li><code>ManualProvisioner</code>: For manually managed environments</li> <li><code>DockerProvisioner</code>: For Docker container environments</li> <li><code>KubernetesProvisioner</code>: For Kubernetes deployments</li> <li><code>AWSProvisioner</code>: For AWS EC2 instances</li> <li><code>AzureProvisioner</code>: For Azure VMs</li> <li><code>GCPProvisioner</code>: For Google Cloud Platform VMs</li> </ul>"},{"location":"concepts/#gym-framework","title":"Gym Framework","text":"<p>The Gym Framework is a reinforcement learning framework inspired by OpenAI Gym, designed specifically for training agents to use computers.</p> <p>Key components of the gym framework include:</p> <ul> <li>Environments: Represent tasks that agents can interact with</li> <li>Agents: Entities that interact with environments by taking actions</li> <li>Episodes: Sequences of interactions between agents and environments</li> <li>Drivers: Manage the interaction between agents and environments</li> <li>Trainers: Train agents using episodes collected by drivers</li> </ul> <p>The gym framework implements the standard reinforcement learning loop:</p> <ol> <li>The environment provides an observation</li> <li>The agent selects an action based on the observation</li> <li>The environment executes the action and returns a new observation, reward, and done flag</li> <li>The process repeats until the episode is complete</li> </ol>"},{"location":"concepts/#daemon","title":"Daemon","text":"<p>The Daemon is a service that allows remote control of computers through a REST API. It exposes computer functionality through HTTP endpoints, providing authentication via API tokens.</p> <p>The daemon can be deployed in various environments:</p> <ul> <li>Locally on your machine</li> <li>In Docker containers</li> <li>In Kubernetes clusters</li> <li>On cloud VMs</li> </ul> <p>The <code>DaemonClientComputer</code> can use provisioners to automatically set up and manage daemon environments, making it easy to create and control remote computers.</p>"},{"location":"concepts/#types","title":"Types","text":"<p>The Types system defines the data models used throughout CommandLAB. These include:</p> <ul> <li>Actions: Operations that can be performed on a computer (e.g., <code>ClickAction</code>, <code>TypeAction</code>)</li> <li>Observations: Information about the computer's state (e.g., <code>ScreenshotObservation</code>, <code>MouseStateObservation</code>)</li> <li>Enums: Standardized values for keys, mouse buttons, etc.</li> </ul> <p>The type system includes mappings to convert between CommandLAB's standard types and backend-specific types, allowing CommandLAB to provide a consistent interface while supporting multiple backends.</p>"},{"location":"concepts/#how-they-work-together","title":"How They Work Together","text":"<p>CommandLAB's components are designed to work together in a modular way:</p> <ul> <li>Computers provide a unified interface for controlling different types of computers</li> <li>Provisioners handle the setup and teardown of computer environments</li> <li>The Gym Framework uses computers to train agents through reinforcement learning</li> <li>The Daemon exposes computer functionality through a REST API</li> <li>Types define the common language for actions and observations across the framework</li> </ul> <p>This diagram illustrates how the components interact:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Agent    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Environment \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  Computer   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                              \u2502\n                                              \u25bc\n                                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                        \u2502 Provisioner \u2502\n                                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                              \u2502\n                                              \u25bc\n                                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                        \u2502   Daemon    \u2502\n                                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"concepts/#design-philosophy","title":"Design Philosophy","text":"<p>CommandLAB follows several key design principles:</p> <ol> <li> <p>Unified Interface: All computer implementations share the same interface, making it easy to switch between different backends.</p> </li> <li> <p>Modularity: Components can be used independently or together. For example, you can use a computer without the gym framework, or use the gym framework with any computer implementation.</p> </li> <li> <p>Extensibility: It's easy to add new implementations of core interfaces. For example, you can create a new computer implementation that controls a specialized system while leveraging existing provisioners and the gym framework.</p> </li> <li> <p>Type Safety: Strong typing throughout the codebase ensures that errors are caught at development time rather than runtime.</p> </li> <li> <p>Cloud-Ready: Support for various deployment environments, from local development to cloud-based production.</p> </li> <li> <p>Separation of Concerns: Each component has a clear responsibility, making the system easier to understand and extend.</p> </li> </ol>"},{"location":"concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the core concepts, you can explore each one in more detail:</p> <ul> <li>Computers: Learn about the different computer implementations</li> <li>Provisioners: Understand how to manage computer environments</li> <li>Gym Framework: Discover how to train agents to use computers</li> <li>Daemon: Learn about remote computer control</li> <li>Types: Explore the data models used throughout CommandLAB</li> </ul>"},{"location":"concepts/computers/","title":"Computers","text":"<p>In CommandLAB, a Computer is an object that provides methods to control a computer system - whether it's your local machine, a remote server, or a virtual environment.</p> <p></p>"},{"location":"concepts/computers/#the-basecomputer-interface","title":"The BaseComputer Interface","text":"<p>All computer implementations inherit from the <code>BaseComputer</code> class, which defines a standard interface:</p> <pre><code>class BaseComputer:\n    def get_screenshot(self) -&gt; ScreenshotObservation:\n        \"\"\"Return a screenshot of the computer\"\"\"\n\n    def get_mouse_state(self) -&gt; MouseStateObservation:\n        \"\"\"Return the current mouse state\"\"\"\n\n    def get_keyboard_state(self) -&gt; KeyboardStateObservation:\n        \"\"\"Return the current keyboard state\"\"\"\n\n    def execute_command(self, action: CommandAction) -&gt; bool:\n        \"\"\"Execute a system command\"\"\"\n\n    def execute_keyboard_key_press(self, action: KeyboardKeyPressAction) -&gt; bool:\n        \"\"\"Press a keyboard key\"\"\"\n\n    # ... and many more methods for mouse/keyboard control\n</code></pre> <p>This unified interface means you can write code that works with any computer implementation.</p>"},{"location":"concepts/computers/#available-computer-implementations","title":"Available Computer Implementations","text":"<p>CommandLAB includes several computer implementations:</p>"},{"location":"concepts/computers/#localpynputcomputer","title":"LocalPynputComputer","text":"<p>Uses the <code>pynput</code> library to control your local computer:</p> <pre><code>from commandLAB.computers.local_pynput_computer import LocalPynputComputer\n\ncomputer = LocalPynputComputer()\n</code></pre>"},{"location":"concepts/computers/#localpyautoguicomputer","title":"LocalPyAutoGUIComputer","text":"<p>Uses the <code>pyautogui</code> library for local control:</p> <pre><code>from commandLAB.computers.local_pyautogui_computer import LocalPyAutoGUIComputer\n\ncomputer = LocalPyAutoGUIComputer()\n</code></pre>"},{"location":"concepts/computers/#e2bdesktopcomputer","title":"E2BDesktopComputer","text":"<p>Uses the E2B Desktop Sandbox for secure interactions:</p> <pre><code>from commandLAB.computers.e2b_desktop_computer import E2BDesktopComputer\n\ncomputer = E2BDesktopComputer()\n</code></pre>"},{"location":"concepts/computers/#daemonclientcomputer","title":"DaemonClientComputer","text":"<p>Connects to a remote daemon for computer control:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer\n\ncomputer = DaemonClientComputer(\n    daemon_base_url=\"http://remote-computer\",\n    daemon_port=8000\n)\n</code></pre>"},{"location":"concepts/computers/#why-multiple-implementations","title":"Why Multiple Implementations?","text":"<p>Different computer implementations serve different needs:</p> <ul> <li>Local control is simple and direct but only works on your machine</li> <li>Remote control via daemon allows controlling computers over a network</li> <li>Sandboxed environments provide isolation for security</li> <li>Cloud deployments enable scaling and distribution</li> </ul>"},{"location":"concepts/computers/#creating-your-own-computer-implementation","title":"Creating Your Own Computer Implementation","text":"<p>You can create your own computer implementation by subclassing <code>BaseComputer</code>:</p> <pre><code>from commandLAB.computers.base_computer import BaseComputer\nfrom commandLAB.types import ScreenshotObservation, CommandAction\n\nclass MyCustomComputer(BaseComputer):\n    def get_screenshot(self) -&gt; ScreenshotObservation:\n        # Your implementation here\n\n    def execute_command(self, action: CommandAction) -&gt; bool:\n        # Your implementation here\n\n    # Implement other required methods...\n</code></pre> <p>This allows you to integrate CommandLAB with any system that can be controlled programmatically.</p>"},{"location":"concepts/daemon/","title":"Daemon","text":"<p>The CommandLAB daemon is a service that allows remote control of computers through a REST API.</p> <p></p>"},{"location":"concepts/daemon/#what-is-the-daemon","title":"What is the Daemon?","text":"<p>The daemon is a FastAPI server that:</p> <ol> <li>Exposes computer functionality through HTTP endpoints</li> <li>Provides authentication via API tokens</li> <li>Can be deployed in various environments (local, Docker, cloud)</li> </ol> <p>This allows you to control computers remotely, even across networks or cloud environments.</p>"},{"location":"concepts/daemon/#starting-the-daemon","title":"Starting the Daemon","text":"<p>You can start the daemon using the CLI:</p> <pre><code>python -m commandLAB.daemon.cli start --port 8000 --backend pynput\n</code></pre> <p>This starts a daemon server on port 8000 using the pynput backend for computer control.</p>"},{"location":"concepts/daemon/#daemon-api","title":"Daemon API","text":"<p>The daemon exposes endpoints for all computer actions:</p> <ul> <li><code>/screenshot</code> - Get a screenshot</li> <li><code>/mouse/state</code> - Get mouse state</li> <li><code>/keyboard/state</code> - Get keyboard state</li> <li><code>/command</code> - Execute a command</li> <li><code>/keyboard/key/down</code> - Press a key down</li> <li><code>/keyboard/key/release</code> - Release a key</li> <li><code>/mouse/move</code> - Move the mouse</li> <li><code>/mouse/button/down</code> - Press a mouse button</li> <li><code>/mouse/button/up</code> - Release a mouse button</li> <li>... and more</li> </ul> <p>All endpoints require authentication via an API token, which is generated when the daemon starts.</p>"},{"location":"concepts/daemon/#connecting-to-the-daemon","title":"Connecting to the Daemon","text":"<p>You can connect to the daemon using the <code>DaemonClientComputer</code>:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer\n\ncomputer = DaemonClientComputer(\n    daemon_base_url=\"http://localhost\",\n    daemon_port=8000\n)\n</code></pre> <p>This creates a computer object that sends commands to the daemon over HTTP.</p>"},{"location":"concepts/daemon/#daemon-with-provisioners","title":"Daemon with Provisioners","text":"<p>The <code>DaemonClientComputer</code> can use provisioners to automatically set up and manage daemon environments:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\n# Create a computer with Docker provisioning\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER\n)\n\n# This automatically:\n# 1. Creates a Docker container with the daemon\n# 2. Starts the daemon in the container\n# 3. Connects to the daemon\n\n# When you're done:\ncomputer.close()  # Stops and removes the container\n</code></pre>"},{"location":"concepts/daemon/#security-considerations","title":"Security Considerations","text":"<p>The daemon includes several security features:</p> <ul> <li>API Token Authentication: All requests require a valid token</li> <li>HTTPS Support: Can be configured to use HTTPS for encrypted communication</li> <li>Isolation: When deployed in containers or VMs, provides isolation from the host</li> </ul> <p>However, you should be careful when exposing the daemon to untrusted networks, as it provides full control over the computer it runs on.</p>"},{"location":"concepts/daemon/#customizing-the-daemon","title":"Customizing the Daemon","text":"<p>You can customize the daemon by creating your own instance of <code>ComputerDaemon</code>:</p> <pre><code>from commandLAB.daemon.server import ComputerDaemon\nfrom commandLAB.computers.local_pynput_computer import LocalPynputComputer\nimport uvicorn\n\n# Create a custom daemon\ndaemon = ComputerDaemon(\n    computer_cls=LocalPynputComputer,\n    computer_cls_kwargs={\"custom_option\": True}\n)\n\n# Start the server\nuvicorn.run(daemon.app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>This allows you to use custom computer implementations or configuration options with the daemon.</p>"},{"location":"concepts/gym/","title":"Gym Framework","text":"<p>CommandLAB includes a reinforcement learning framework inspired by OpenAI Gym, designed specifically for training agents to use computers.</p> <p></p>"},{"location":"concepts/gym/#core-concepts","title":"Core Concepts","text":"<p>The gym framework is built around several key concepts:</p>"},{"location":"concepts/gym/#environments","title":"Environments","text":"<p>An Environment represents a task that an agent can interact with. In CommandLAB, environments typically wrap a computer:</p> <pre><code>from commandLAB.gym.environments.computer_env import ComputerEnv, ComputerEnvConfig\n\n# Configure the environment\nconfig = ComputerEnvConfig(\n    computer_cls_name=\"LocalPynputComputer\",\n    on_reset_python=\"echo 'Environment reset'\"\n)\n\n# Create the environment\nenv = ComputerEnv(config)\n</code></pre>"},{"location":"concepts/gym/#agents","title":"Agents","text":"<p>An Agent is an entity that interacts with an environment by taking actions based on observations:</p> <pre><code>from commandLAB.gym.agents.naive_vision_language_computer_agent import NaiveComputerAgent\n\n# Create an agent\nagent = NaiveComputerAgent(chat_model_options={\n    \"model\": \"gpt-4-vision-preview\"\n})\n</code></pre>"},{"location":"concepts/gym/#episodes-and-steps","title":"Episodes and Steps","text":"<p>An Episode is a sequence of interactions between an agent and an environment:</p> <pre><code>from commandLAB.gym.schema import Episode, Step\n\n# A step contains an observation, action, reward, and info\nstep = Step(\n    observation=observation,\n    action=action,\n    reward=1.0,\n    info={\"success\": True}\n)\n\n# An episode is a collection of steps\nepisode = Episode()\nepisode.push(step)\n</code></pre>"},{"location":"concepts/gym/#drivers","title":"Drivers","text":"<p>A Driver manages the interaction between agents and environments:</p> <pre><code>from commandLAB.gym.drivers import SimpleDriver\n\n# Create a driver\ndriver = SimpleDriver(env=env, agent=agent)\n\n# Collect an episode\nepisode = driver.collect_episode()\n</code></pre>"},{"location":"concepts/gym/#the-reinforcement-learning-loop","title":"The Reinforcement Learning Loop","text":"<p>The gym framework implements the standard reinforcement learning loop:</p> <ol> <li>The environment provides an observation</li> <li>The agent selects an action based on the observation</li> <li>The environment executes the action and returns a new observation, reward, and done flag</li> <li>The process repeats until the episode is complete</li> </ol> <pre><code># Reset the environment\nobservation = env.reset()\n\n# Agent-environment loop\ndone = False\nwhile not done:\n    # Agent selects action\n    action = agent.act(observation)\n\n    # Environment executes action\n    observation, reward, done, info = env.step(action)\n\n    # Agent updates based on reward\n    agent.update(reward)\n</code></pre>"},{"location":"concepts/gym/#available-environments","title":"Available Environments","text":"<p>CommandLAB includes several environment types:</p>"},{"location":"concepts/gym/#baseenv","title":"BaseEnv","text":"<p>The abstract base class for all environments:</p> <pre><code>class BaseEnv(Generic[ObsType, ActionType], ABC):\n    def reset(self) -&gt; ObsType:\n        \"\"\"Reset the environment\"\"\"\n\n    def step(self, action: ActionType) -&gt; Tuple[ObsType, float, bool, Dict[str, Any]]:\n        \"\"\"Execute action and return (observation, reward, done, info)\"\"\"\n\n    def close(self):\n        \"\"\"Clean up resources\"\"\"\n</code></pre>"},{"location":"concepts/gym/#multimodalenv","title":"MultiModalEnv","text":"<p>An environment with multiple observation and action types:</p> <pre><code>class MultiModalEnv(BaseEnv[ObsType, ActT]):\n    def __init__(\n        self,\n        observation_fns: Dict[str, Callable[[], Any]],\n        action_fns: Dict[str, Callable[[Any], bool]],\n        observation_type: type,\n    ):\n        # ...\n</code></pre>"},{"location":"concepts/gym/#computerenv","title":"ComputerEnv","text":"<p>An environment specifically for computer interaction:</p> <pre><code>class ComputerEnv(MultiModalEnv[ComputerObservation, ComputerAction]):\n    def __init__(self, config: ComputerEnvConfig, computer: BaseComputer = None):\n        # ...\n</code></pre>"},{"location":"concepts/gym/#available-agents","title":"Available Agents","text":"<p>CommandLAB includes several agent implementations:</p>"},{"location":"concepts/gym/#basecomputeragent","title":"BaseComputerAgent","text":"<p>The abstract base class for all computer agents:</p> <pre><code>class BaseComputerAgent(ABC):\n    def reset(self) -&gt; None:\n        \"\"\"Reset the agent's internal state\"\"\"\n\n    def act(self, observation: ComputerObservation) -&gt; ComputerAction:\n        \"\"\"Given an observation, determine the next action\"\"\"\n\n    def update(self, reward: float) -&gt; None:\n        \"\"\"Update the agent's internal state based on the reward\"\"\"\n\n    def train(self, episodes: list[Episode]) -&gt; None:\n        \"\"\"Train the agent on episodes\"\"\"\n</code></pre>"},{"location":"concepts/gym/#naivecomputeragent","title":"NaiveComputerAgent","text":"<p>A simple agent that uses a vision-language model to control computers:</p> <pre><code>class NaiveComputerAgent(BaseComputerAgent):\n    def __init__(self, chat_model_options: dict):\n        self.chat_model = get_chat_model(**chat_model_options)\n        # ...\n</code></pre>"},{"location":"concepts/gym/#reactcomputeragent","title":"ReactComputerAgent","text":"<p>An agent that uses the ReAct framework for reasoning:</p> <pre><code>class ReactComputerAgent(BaseComputerAgent):\n    def __init__(self, model: str, device: Optional[str] = None):\n        self.agent = Agent(model, device=device)\n        # ...\n</code></pre>"},{"location":"concepts/gym/#creating-custom-agents-and-environments","title":"Creating Custom Agents and Environments","text":"<p>You can create custom agents and environments by implementing the appropriate interfaces:</p> <pre><code># Custom agent\nclass MyCustomAgent(BaseComputerAgent):\n    def act(self, observation: ComputerObservation) -&gt; ComputerAction:\n        # Your decision logic here\n\n# Custom environment\nclass MyCustomEnvironment(BaseEnv[MyObsType, MyActionType]):\n    def step(self, action: MyActionType) -&gt; Tuple[MyObsType, float, bool, Dict[str, Any]]:\n        # Your environment logic here\n</code></pre> <p>This flexibility allows you to create specialized agents and environments for specific tasks.</p>"},{"location":"concepts/provisioners/","title":"Provisioners","text":"<p>Provisioners in CommandLAB handle the setup, management, and teardown of computer environments. They're especially useful for cloud and container deployments.</p> <p></p>"},{"location":"concepts/provisioners/#what-is-a-provisioner","title":"What is a Provisioner?","text":"<p>A provisioner is responsible for:</p> <ol> <li>Setting up a computer environment (e.g., starting a Docker container)</li> <li>Checking if the environment is running</li> <li>Tearing down the environment when it's no longer needed</li> </ol> <p>This allows CommandLAB to work with ephemeral environments that can be created and destroyed as needed.</p>"},{"location":"concepts/provisioners/#the-basecomputerprovisioner-interface","title":"The BaseComputerProvisioner Interface","text":"<p>All provisioners implement the <code>BaseComputerProvisioner</code> interface:</p> <pre><code>class BaseComputerProvisioner:\n    def __init__(self, port: int = 8000):\n        self.port = port\n\n    def setup(self) -&gt; None:\n        \"\"\"Setup the computer environment\"\"\"\n\n    def teardown(self) -&gt; None:\n        \"\"\"Cleanup resources\"\"\"\n\n    def is_running(self) -&gt; bool:\n        \"\"\"Check if the environment is running\"\"\"\n\n    def get_status(self) -&gt; str:\n        \"\"\"Get the current status of the provisioner\"\"\"\n        return self._status\n</code></pre>"},{"location":"concepts/provisioners/#available-provisioners","title":"Available Provisioners","text":"<p>CommandLAB includes provisioners for various deployment options:</p>"},{"location":"concepts/provisioners/#manualprovisioner","title":"ManualProvisioner","text":"<p>Provides instructions for manual setup:</p> <pre><code>from commandLAB.computers.provisioners.manual_provisioner import ManualProvisioner\n\nprovisioner = ManualProvisioner(port=8000)\nprovisioner.setup()  # Prints instructions\n</code></pre>"},{"location":"concepts/provisioners/#dockerprovisioner","title":"DockerProvisioner","text":"<p>Deploys environments in Docker containers:</p> <pre><code>from commandLAB.computers.provisioners.docker_provisioner import DockerProvisioner, DockerPlatform\n\nprovisioner = DockerProvisioner(\n    port=8000,\n    platform=DockerPlatform.LOCAL\n)\nprovisioner.setup()  # Creates and starts a Docker container\n</code></pre>"},{"location":"concepts/provisioners/#kubernetesprovisioner","title":"KubernetesProvisioner","text":"<p>Manages deployments in Kubernetes clusters:</p> <pre><code>from commandLAB.computers.provisioners.kubernetes_provisioner import KubernetesProvisioner, KubernetesPlatform\n\nprovisioner = KubernetesProvisioner(\n    port=8000,\n    platform=KubernetesPlatform.GCP_GKE,\n    namespace=\"commandlab\"\n)\n</code></pre>"},{"location":"concepts/provisioners/#cloud-provisioners","title":"Cloud Provisioners","text":"<p>Provision VMs in various cloud providers:</p> <pre><code># AWS EC2\nfrom commandLAB.computers.provisioners.aws_provisioner import AWSProvisioner\nprovisioner = AWSProvisioner(region=\"us-west-2\")\n\n# Azure VM\nfrom commandLAB.computers.provisioners.azure_provisioner import AzureProvisioner\nprovisioner = AzureProvisioner(resource_group=\"my-resource-group\")\n\n# Google Cloud\nfrom commandLAB.computers.provisioners.gcp_provisioner import GCPProvisioner\nprovisioner = GCPProvisioner(project=\"my-project\")\n</code></pre>"},{"location":"concepts/provisioners/#how-provisioners-work-with-computers","title":"How Provisioners Work with Computers","text":"<p>The <code>DaemonClientComputer</code> uses provisioners to manage its environment:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\n# Create a computer with Docker provisioning\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER\n)\n\n# This automatically:\n# 1. Creates a provisioner based on the method\n# 2. Calls provisioner.setup() to create the environment\n# 3. Connects to the daemon in that environment\n\n# When you're done:\ncomputer.close()  # Calls provisioner.teardown()\n</code></pre>"},{"location":"concepts/provisioners/#creating-custom-provisioners","title":"Creating Custom Provisioners","text":"<p>You can create custom provisioners by implementing the <code>BaseComputerProvisioner</code> interface:</p> <pre><code>from commandLAB.computers.provisioners.base_provisioner import BaseComputerProvisioner\n\nclass MyCustomProvisioner(BaseComputerProvisioner):\n    def setup(self) -&gt; None:\n        # Your setup logic here\n\n    def teardown(self) -&gt; None:\n        # Your cleanup logic here\n\n    def is_running(self) -&gt; bool:\n        # Your status check logic here\n</code></pre> <p>This allows you to integrate CommandLAB with any infrastructure or deployment system.</p>"},{"location":"concepts/provisioners/#advanced-features","title":"Advanced Features","text":"<p>The provisioners in CommandLAB include several advanced features:</p> <ul> <li>Retry Logic: Automatically retry operations that fail transiently</li> <li>Timeouts: Prevent operations from hanging indefinitely</li> <li>Status Tracking: Monitor the state of resources</li> <li>Logging: Detailed logging for troubleshooting</li> <li>Resource Cleanup: Ensure proper cleanup of all resources</li> </ul>"},{"location":"concepts/provisioners/#further-reading","title":"Further Reading","text":"<ul> <li>Using Provisioners Guide - A user-focused guide on using provisioners</li> <li>Provisioner System for Developers - Detailed information for library developers</li> <li>Cloud Containers Guide - Guide for running CommandLAB in cloud container services</li> </ul>"},{"location":"concepts/types/","title":"Types","text":"<p>CommandLAB uses a comprehensive type system to define actions, observations, and other data structures.</p> <p></p>"},{"location":"concepts/types/#core-types","title":"Core Types","text":""},{"location":"concepts/types/#actions","title":"Actions","text":"<p>Actions represent operations that can be performed on a computer:</p> <pre><code>from commandLAB.types import (\n    ClickAction,\n    TypeAction,\n    KeyboardHotkeyAction,\n    KeyboardKey,\n    MouseButton\n)\n\n# Click at coordinates\nclick_action = ClickAction(\n    x=100, \n    y=200, \n    button=MouseButton.LEFT\n)\n\n# Type text\ntype_action = TypeAction(\n    text=\"Hello, CommandLAB!\"\n)\n\n# Press a keyboard shortcut\nhotkey_action = KeyboardHotkeyAction(\n    keys=[KeyboardKey.CTRL, KeyboardKey.C]\n)\n</code></pre>"},{"location":"concepts/types/#observations","title":"Observations","text":"<p>Observations represent the state of a computer:</p> <pre><code>from commandLAB.types import (\n    ScreenshotObservation,\n    MouseStateObservation,\n    KeyboardStateObservation\n)\n\n# Screenshot\nscreenshot = ScreenshotObservation(\n    screenshot=\"base64_encoded_image_data\"\n)\n\n# Mouse state\nmouse_state = MouseStateObservation(\n    buttons={MouseButton.LEFT: False, MouseButton.RIGHT: False},\n    position=(100, 200)\n)\n\n# Keyboard state\nkeyboard_state = KeyboardStateObservation(\n    keys={KeyboardKey.SHIFT: True, KeyboardKey.A: False}\n)\n</code></pre>"},{"location":"concepts/types/#computeraction-and-computerobservation","title":"ComputerAction and ComputerObservation","text":"<p>These are container types that can hold any action or observation:</p> <pre><code>from commandLAB.types import ComputerAction, ComputerObservation\n\n# An action that could be any type of action\naction = ComputerAction(\n    click=ClickAction(x=100, y=200),\n    # All other action fields are None\n)\n\n# An observation that could include any type of observation\nobservation = ComputerObservation(\n    screenshot=screenshot,\n    mouse_state=mouse_state,\n    keyboard_state=keyboard_state\n)\n</code></pre>"},{"location":"concepts/types/#enums","title":"Enums","text":"<p>CommandLAB includes several enums for standardizing values:</p>"},{"location":"concepts/types/#mousebutton","title":"MouseButton","text":"<pre><code>class MouseButton(str, Enum):\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    MIDDLE = \"middle\"\n</code></pre>"},{"location":"concepts/types/#keyboardkey","title":"KeyboardKey","text":"<pre><code>class KeyboardKey(str, Enum):\n    # Special Keys\n    ENTER = \"enter\"\n    TAB = \"tab\"\n    SPACE = \"space\"\n    # ... many more keys\n\n    # Alphabet\n    A = \"a\"\n    B = \"b\"\n    # ... and so on\n</code></pre>"},{"location":"concepts/types/#backend-mappings","title":"Backend Mappings","text":"<p>The type system includes mappings to convert between CommandLAB's standard types and backend-specific types:</p> <pre><code># Convert a CommandLAB mouse button to a PyAutoGUI button\npyautogui_button = MouseButton.to_pyautogui(MouseButton.LEFT)  # \"left\"\n\n# Convert a CommandLAB key to a pynput key\npynput_key = KeyboardKey.to_pynput(KeyboardKey.ENTER)  # pynput.keyboard.Key.enter\n</code></pre> <p>This allows CommandLAB to provide a consistent interface while supporting multiple backends.</p>"},{"location":"concepts/types/#why-strong-typing","title":"Why Strong Typing?","text":"<p>CommandLAB uses strong typing for several reasons:</p> <ol> <li>API Clarity: Makes it clear what data is expected</li> <li>Error Prevention: Catches type errors at development time</li> <li>Documentation: Types serve as documentation</li> <li>IDE Support: Enables autocomplete and type hints</li> <li>Serialization: Simplifies conversion to/from JSON</li> </ol>"},{"location":"concepts/types/#using-types-in-your-code","title":"Using Types in Your Code","text":"<p>When working with CommandLAB, you'll typically use these types to create actions and process observations:</p> <pre><code>from commandLAB.computers.local_pynput_computer import LocalPynputComputer\nfrom commandLAB.types import ClickAction, TypeAction\n\ncomputer = LocalPynputComputer()\n\n# Create and execute actions\ncomputer.execute_click(ClickAction(x=100, y=200))\ncomputer.execute_type(TypeAction(text=\"Hello!\"))\n\n# Get and process observations\nscreenshot = computer.get_screenshot()\nmouse_state = computer.get_mouse_state()\n</code></pre> <p>Understanding the type system is key to effectively using CommandLAB.</p>"},{"location":"developers/","title":"Developer Guide","text":"<p>Welcome to the CommandLAB developer guide! This section provides detailed information for developers who want to contribute to CommandLAB or extend it for their own projects.</p>"},{"location":"developers/#getting-started","title":"Getting Started","text":"<ul> <li>Development Environment Setup - Setting up your development environment</li> <li>Project Structure - Understanding the CommandLAB project structure</li> <li>Coding Standards - Coding standards and style guidelines</li> <li>Contributing Guidelines - How to contribute to CommandLAB</li> </ul>"},{"location":"developers/#architecture","title":"Architecture","text":"<ul> <li>Architecture Overview - High-level overview of the CommandLAB architecture</li> <li>Core Components - Detailed explanation of core components</li> <li>Design Patterns - Design patterns used in CommandLAB</li> <li>Type System - Detailed explanation of the type system</li> </ul>"},{"location":"developers/#component-documentation","title":"Component Documentation","text":"<ul> <li>Computer System - Detailed documentation of the computer system</li> <li>Provisioner System - Detailed documentation of the provisioner system</li> <li>Daemon System - Detailed documentation of the daemon system</li> <li>Gym Framework - Detailed documentation of the gym framework</li> </ul>"},{"location":"developers/#extension-points","title":"Extension Points","text":"<ul> <li>Creating Custom Computers - How to create custom computer implementations</li> <li>Creating Custom Provisioners - How to create custom provisioner implementations</li> <li>Creating Custom Agents - How to create custom agent implementations</li> <li>Creating Custom Environments - How to create custom environment implementations</li> </ul>"},{"location":"developers/#testing","title":"Testing","text":"<ul> <li>Testing Strategy - Overall testing strategy</li> <li>Unit Testing - Writing unit tests</li> <li>Integration Testing - Writing integration tests</li> <li>End-to-End Testing - Writing end-to-end tests</li> </ul>"},{"location":"developers/#build-and-release","title":"Build and Release","text":"<ul> <li>Build System - Understanding the build system</li> <li>Release Process - How releases are managed</li> <li>Versioning - Versioning strategy</li> <li>Documentation Generation - How documentation is generated</li> </ul>"},{"location":"developers/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Performance Optimization - Optimizing CommandLAB performance</li> <li>Security Considerations - Security considerations for developers</li> <li>Cross-Platform Development - Developing for multiple platforms</li> <li>Cloud Integration - Integrating with cloud providers</li> <li>CI/CD Integration - Integrating with CI/CD pipelines</li> </ul>"},{"location":"developers/#api-reference","title":"API Reference","text":"<ul> <li>Core API - Core API reference</li> <li>Computer API - Computer API reference</li> <li>Provisioner API - Provisioner API reference</li> <li>Daemon API - Daemon API reference</li> <li>Gym API - Gym API reference</li> </ul>"},{"location":"developers/#internals","title":"Internals","text":"<ul> <li>Dependency Management - How dependencies are managed</li> <li>Error Handling - Error handling strategy</li> <li>Logging System - Logging system details</li> <li>Configuration System - Configuration system details</li> </ul>"},{"location":"developers/#examples","title":"Examples","text":"<ul> <li>Example: Custom Computer - Example of creating a custom computer</li> <li>Example: Custom Provisioner - Example of creating a custom provisioner</li> <li>Example: Custom Agent - Example of creating a custom agent</li> <li>Example: Custom Environment - Example of creating a custom environment</li> </ul>"},{"location":"developers/#related-tutorials","title":"Related Tutorials","text":"<p>For step-by-step guides on extending CommandLAB, see these tutorials:</p> <ul> <li>Custom Computers - Implementing custom computer backends</li> <li>Custom Provisioners - Creating custom provisioning solutions</li> <li>Custom Agents - Creating your own AI agents</li> <li>CI/CD Integration - Integrating CommandLAB into CI/CD pipelines</li> </ul>"},{"location":"developers/#community","title":"Community","text":"<ul> <li>Community Guidelines - Guidelines for the CommandLAB community</li> <li>Code of Conduct - Code of conduct for contributors</li> <li>Governance - Project governance</li> <li>Roadmap - Project roadmap </li> </ul>"},{"location":"developers/custom_computers/","title":"Creating Custom Computers","text":"<p>This guide explains how to create custom computer implementations in CommandLAB. Custom computers allow you to extend CommandLAB to control new types of systems or to integrate with existing automation frameworks.</p>"},{"location":"developers/custom_computers/#introduction","title":"Introduction","text":"<p>The <code>BaseComputer</code> class in CommandLAB defines a standard interface for controlling computers. By implementing this interface, you can create custom computer implementations that work with the rest of the CommandLAB ecosystem.</p> <p>Some reasons to create a custom computer implementation:</p> <ul> <li>Integrate with a specialized hardware platform</li> <li>Support a new remote control protocol</li> <li>Optimize for specific performance requirements</li> <li>Add support for new input/output devices</li> <li>Integrate with existing automation frameworks</li> </ul>"},{"location":"developers/custom_computers/#prerequisites","title":"Prerequisites","text":"<p>Before creating a custom computer implementation, you should:</p> <ul> <li>Understand the <code>BaseComputer</code> interface</li> <li>Be familiar with Python and object-oriented programming</li> <li>Have a clear use case for your custom implementation</li> </ul>"},{"location":"developers/custom_computers/#the-basecomputer-interface","title":"The BaseComputer Interface","text":"<p>The <code>BaseComputer</code> class defines the following key methods:</p> <pre><code>class BaseComputer(BaseModel):\n    def get_screenshot(self) -&gt; ScreenshotObservation:\n        \"\"\"Return a screenshot of the computer\"\"\"\n\n    def get_mouse_state(self) -&gt; MouseStateObservation:\n        \"\"\"Return the current mouse state\"\"\"\n\n    def get_keyboard_state(self) -&gt; KeyboardStateObservation:\n        \"\"\"Return the current keyboard state\"\"\"\n\n    def execute_command(self, action: CommandAction) -&gt; bool:\n        \"\"\"Execute a system command\"\"\"\n\n    def execute_keyboard_key_down(self, action: KeyboardKeyDownAction) -&gt; bool:\n        \"\"\"Execute key down for a keyboard key\"\"\"\n\n    def execute_keyboard_key_release(self, action: KeyboardKeyReleaseAction) -&gt; bool:\n        \"\"\"Execute key release for a keyboard key\"\"\"\n\n    def execute_mouse_move(self, action: MouseMoveAction) -&gt; bool:\n        \"\"\"Execute moving the mouse\"\"\"\n\n    def execute_mouse_scroll(self, action: MouseScrollAction) -&gt; bool:\n        \"\"\"Execute mouse scroll\"\"\"\n\n    def execute_mouse_button_down(self, action: MouseButtonDownAction) -&gt; bool:\n        \"\"\"Execute mouse button down\"\"\"\n\n    def execute_mouse_button_up(self, action: MouseButtonUpAction) -&gt; bool:\n        \"\"\"Execute mouse button up\"\"\"\n</code></pre> <p>The base class also provides default implementations for composite actions like <code>execute_click</code>, <code>execute_type</code>, and <code>execute_keyboard_hotkey</code>, which are built on top of the primitive actions.</p>"},{"location":"developers/custom_computers/#step-1-create-a-new-computer-class","title":"Step 1: Create a New Computer Class","text":"<p>Start by creating a new class that inherits from <code>BaseComputer</code>:</p> <pre><code>from commandLAB.computers.base_computer import BaseComputer\nfrom commandLAB.types import (\n    ScreenshotObservation,\n    MouseStateObservation,\n    KeyboardStateObservation,\n    CommandAction,\n    KeyboardKeyDownAction,\n    KeyboardKeyReleaseAction,\n    MouseMoveAction,\n    MouseScrollAction,\n    MouseButtonDownAction,\n    MouseButtonUpAction,\n)\n\nclass MyCustomComputer(BaseComputer):\n    def __init__(self, custom_param: str = \"default\"):\n        super().__init__()\n        self.custom_param = custom_param\n        # Initialize your custom resources here\n\n    def close(self):\n        \"\"\"Clean up resources when the object is destroyed\"\"\"\n        # Clean up your custom resources here\n        pass\n</code></pre>"},{"location":"developers/custom_computers/#step-2-implement-required-methods","title":"Step 2: Implement Required Methods","text":"<p>Next, implement the required methods from the <code>BaseComputer</code> interface:</p> <pre><code>class MyCustomComputer(BaseComputer):\n    # ... __init__ and other methods ...\n\n    def get_screenshot(self) -&gt; ScreenshotObservation:\n        \"\"\"Return a screenshot of the computer\"\"\"\n        # Implement screenshot capture logic\n        screenshot_data = \"base64_encoded_screenshot_data\"  # Replace with actual implementation\n        return ScreenshotObservation(screenshot=screenshot_data)\n\n    def get_mouse_state(self) -&gt; MouseStateObservation:\n        \"\"\"Return the current mouse state\"\"\"\n        # Implement mouse state retrieval logic\n        buttons = {MouseButton.LEFT: False, MouseButton.RIGHT: False, MouseButton.MIDDLE: False}\n        position = (0, 0)  # Replace with actual implementation\n        return MouseStateObservation(buttons=buttons, position=position)\n\n    def get_keyboard_state(self) -&gt; KeyboardStateObservation:\n        \"\"\"Return the current keyboard state\"\"\"\n        # Implement keyboard state retrieval logic\n        keys = {key: False for key in KeyboardKey}  # Replace with actual implementation\n        return KeyboardStateObservation(keys=keys)\n\n    def execute_command(self, action: CommandAction) -&gt; bool:\n        \"\"\"Execute a system command\"\"\"\n        # Implement command execution logic\n        command = action.command\n        timeout = action.timeout\n        # Execute the command and return success/failure\n        return True  # Replace with actual implementation\n\n    def execute_keyboard_key_down(self, action: KeyboardKeyDownAction) -&gt; bool:\n        \"\"\"Execute key down for a keyboard key\"\"\"\n        # Implement key down logic\n        key = action.key\n        # Press the key and return success/failure\n        return True  # Replace with actual implementation\n\n    def execute_keyboard_key_release(self, action: KeyboardKeyReleaseAction) -&gt; bool:\n        \"\"\"Execute key release for a keyboard key\"\"\"\n        # Implement key release logic\n        key = action.key\n        # Release the key and return success/failure\n        return True  # Replace with actual implementation\n\n    def execute_mouse_move(self, action: MouseMoveAction) -&gt; bool:\n        \"\"\"Execute moving the mouse\"\"\"\n        # Implement mouse move logic\n        x = action.x\n        y = action.y\n        move_duration = action.move_duration\n        # Move the mouse and return success/failure\n        return True  # Replace with actual implementation\n\n    def execute_mouse_scroll(self, action: MouseScrollAction) -&gt; bool:\n        \"\"\"Execute mouse scroll\"\"\"\n        # Implement mouse scroll logic\n        amount = action.amount\n        # Scroll the mouse and return success/failure\n        return True  # Replace with actual implementation\n\n    def execute_mouse_button_down(self, action: MouseButtonDownAction) -&gt; bool:\n        \"\"\"Execute mouse button down\"\"\"\n        # Implement mouse button down logic\n        button = action.button\n        # Press the mouse button and return success/failure\n        return True  # Replace with actual implementation\n\n    def execute_mouse_button_up(self, action: MouseButtonUpAction) -&gt; bool:\n        \"\"\"Execute mouse button up\"\"\"\n        # Implement mouse button up logic\n        button = action.button\n        # Release the mouse button and return success/failure\n        return True  # Replace with actual implementation\n</code></pre>"},{"location":"developers/custom_computers/#step-3-implement-custom-methods-optional","title":"Step 3: Implement Custom Methods (Optional)","text":"<p>You can add custom methods specific to your implementation:</p> <pre><code>class MyCustomComputer(BaseComputer):\n    # ... standard methods ...\n\n    def custom_method(self, param: str) -&gt; bool:\n        \"\"\"A custom method specific to this implementation\"\"\"\n        # Custom implementation\n        return True\n</code></pre>"},{"location":"developers/custom_computers/#step-4-override-composite-methods-optional","title":"Step 4: Override Composite Methods (Optional)","text":"<p>If needed, you can override the default implementations of composite methods:</p> <pre><code>class MyCustomComputer(BaseComputer):\n    # ... standard methods ...\n\n    def execute_click(self, action: ClickAction) -&gt; bool:\n        \"\"\"Custom implementation of click action\"\"\"\n        # Custom click implementation that might be more efficient\n        # than the default implementation that uses move, button down, and button up\n        return True\n</code></pre>"},{"location":"developers/custom_computers/#example-webdrivercomputer","title":"Example: WebDriverComputer","text":"<p>Here's an example of a custom computer implementation that uses Selenium WebDriver to control a web browser:</p> <pre><code>from selenium import webdriver\nfrom selenium.webdriver.common.action_chains import ActionChains\nfrom selenium.webdriver.common.keys import Keys\nimport base64\nimport time\n\nfrom commandLAB.computers.base_computer import BaseComputer\nfrom commandLAB.types import (\n    ScreenshotObservation,\n    MouseStateObservation,\n    KeyboardStateObservation,\n    CommandAction,\n    KeyboardKeyDownAction,\n    KeyboardKeyReleaseAction,\n    MouseMoveAction,\n    MouseScrollAction,\n    MouseButtonDownAction,\n    MouseButtonUpAction,\n    MouseButton,\n    KeyboardKey,\n)\n\nclass WebDriverComputer(BaseComputer):\n    def __init__(self, browser: str = \"chrome\", headless: bool = False):\n        super().__init__()\n\n        # Initialize WebDriver\n        if browser.lower() == \"chrome\":\n            options = webdriver.ChromeOptions()\n            if headless:\n                options.add_argument(\"--headless\")\n            self.driver = webdriver.Chrome(options=options)\n        elif browser.lower() == \"firefox\":\n            options = webdriver.FirefoxOptions()\n            if headless:\n                options.add_argument(\"--headless\")\n            self.driver = webdriver.Firefox(options=options)\n        else:\n            raise ValueError(f\"Unsupported browser: {browser}\")\n\n        # Initialize ActionChains for mouse and keyboard actions\n        self.actions = ActionChains(self.driver)\n\n        # Set initial window size\n        self.driver.set_window_size(1280, 800)\n\n    def close(self):\n        \"\"\"Clean up resources\"\"\"\n        if hasattr(self, 'driver'):\n            self.driver.quit()\n\n    def get_screenshot(self) -&gt; ScreenshotObservation:\n        \"\"\"Take a screenshot using WebDriver\"\"\"\n        screenshot = self.driver.get_screenshot_as_base64()\n        return ScreenshotObservation(screenshot=screenshot)\n\n    def get_mouse_state(self) -&gt; MouseStateObservation:\n        \"\"\"WebDriver doesn't provide mouse state, so return a default value\"\"\"\n        # This is a limitation of WebDriver\n        buttons = {MouseButton.LEFT: False, MouseButton.RIGHT: False, MouseButton.MIDDLE: False}\n        position = (0, 0)\n        return MouseStateObservation(buttons=buttons, position=position)\n\n    def get_keyboard_state(self) -&gt; KeyboardStateObservation:\n        \"\"\"WebDriver doesn't provide keyboard state, so return a default value\"\"\"\n        # This is a limitation of WebDriver\n        keys = {key: False for key in KeyboardKey}\n        return KeyboardStateObservation(keys=keys)\n\n    def execute_command(self, action: CommandAction) -&gt; bool:\n        \"\"\"Execute a JavaScript command in the browser\"\"\"\n        try:\n            self.driver.execute_script(action.command)\n            return True\n        except Exception as e:\n            print(f\"Error executing command: {e}\")\n            return False\n\n    def execute_keyboard_key_down(self, action: KeyboardKeyDownAction) -&gt; bool:\n        \"\"\"Press a key down using ActionChains\"\"\"\n        try:\n            selenium_key = self._convert_to_selenium_key(action.key)\n            self.actions.key_down(selenium_key).perform()\n            return True\n        except Exception as e:\n            print(f\"Error executing key down: {e}\")\n            return False\n\n    def execute_keyboard_key_release(self, action: KeyboardKeyReleaseAction) -&gt; bool:\n        \"\"\"Release a key using ActionChains\"\"\"\n        try:\n            selenium_key = self._convert_to_selenium_key(action.key)\n            self.actions.key_up(selenium_key).perform()\n            return True\n        except Exception as e:\n            print(f\"Error executing key release: {e}\")\n            return False\n\n    def execute_mouse_move(self, action: MouseMoveAction) -&gt; bool:\n        \"\"\"Move the mouse using ActionChains\"\"\"\n        try:\n            # Find an element at the target position or use move_by_offset\n            self.actions.move_by_offset(action.x, action.y).perform()\n            return True\n        except Exception as e:\n            print(f\"Error executing mouse move: {e}\")\n            return False\n\n    def execute_mouse_scroll(self, action: MouseScrollAction) -&gt; bool:\n        \"\"\"Scroll using JavaScript\"\"\"\n        try:\n            self.driver.execute_script(f\"window.scrollBy(0, {action.amount});\")\n            return True\n        except Exception as e:\n            print(f\"Error executing mouse scroll: {e}\")\n            return False\n\n    def execute_mouse_button_down(self, action: MouseButtonDownAction) -&gt; bool:\n        \"\"\"Press a mouse button using ActionChains\"\"\"\n        try:\n            if action.button == MouseButton.LEFT:\n                self.actions.click_and_hold().perform()\n            elif action.button == MouseButton.RIGHT:\n                self.actions.context_click().perform()\n            return True\n        except Exception as e:\n            print(f\"Error executing mouse button down: {e}\")\n            return False\n\n    def execute_mouse_button_up(self, action: MouseButtonUpAction) -&gt; bool:\n        \"\"\"Release a mouse button using ActionChains\"\"\"\n        try:\n            if action.button == MouseButton.LEFT:\n                self.actions.release().perform()\n            return True\n        except Exception as e:\n            print(f\"Error executing mouse button up: {e}\")\n            return False\n\n    def _convert_to_selenium_key(self, key: KeyboardKey):\n        \"\"\"Convert CommandLAB key to Selenium key\"\"\"\n        key_mapping = {\n            KeyboardKey.ENTER: Keys.ENTER,\n            KeyboardKey.TAB: Keys.TAB,\n            KeyboardKey.SPACE: Keys.SPACE,\n            KeyboardKey.BACKSPACE: Keys.BACKSPACE,\n            KeyboardKey.ESCAPE: Keys.ESCAPE,\n            KeyboardKey.UP: Keys.UP,\n            KeyboardKey.DOWN: Keys.DOWN,\n            KeyboardKey.LEFT: Keys.LEFT,\n            KeyboardKey.RIGHT: Keys.RIGHT,\n            KeyboardKey.SHIFT: Keys.SHIFT,\n            KeyboardKey.CTRL: Keys.CONTROL,\n            KeyboardKey.ALT: Keys.ALT,\n            # Add more mappings as needed\n        }\n\n        if key in key_mapping:\n            return key_mapping[key]\n        else:\n            # For regular keys, just return the key value\n            return key.value\n\n    # Custom methods specific to WebDriver\n\n    def navigate_to(self, url: str) -&gt; bool:\n        \"\"\"Navigate to a URL\"\"\"\n        try:\n            self.driver.get(url)\n            return True\n        except Exception as e:\n            print(f\"Error navigating to {url}: {e}\")\n            return False\n\n    def find_and_click(self, selector: str) -&gt; bool:\n        \"\"\"Find an element by CSS selector and click it\"\"\"\n        try:\n            element = self.driver.find_element_by_css_selector(selector)\n            element.click()\n            return True\n        except Exception as e:\n            print(f\"Error finding and clicking {selector}: {e}\")\n            return False\n</code></pre>"},{"location":"developers/custom_computers/#best-practices","title":"Best Practices","text":""},{"location":"developers/custom_computers/#error-handling","title":"Error Handling","text":"<p>Always include robust error handling in your implementation:</p> <pre><code>def execute_command(self, action: CommandAction) -&gt; bool:\n    try:\n        # Implementation\n        return True\n    except Exception as e:\n        print(f\"Error executing command: {e}\")\n        return False\n</code></pre>"},{"location":"developers/custom_computers/#resource-management","title":"Resource Management","text":"<p>Properly manage resources in the <code>__init__</code> and <code>close</code> methods:</p> <pre><code>def __init__(self):\n    super().__init__()\n    # Acquire resources\n\ndef close(self):\n    try:\n        # Release resources\n        pass\n    except Exception as e:\n        print(f\"Error closing resources: {e}\")\n</code></pre>"},{"location":"developers/custom_computers/#documentation","title":"Documentation","text":"<p>Document your implementation thoroughly:</p> <pre><code>class MyCustomComputer(BaseComputer):\n    \"\"\"\n    A custom computer implementation that controls XYZ system.\n\n    This implementation uses the ABC library to interact with XYZ hardware.\n    It supports all standard CommandLAB actions and adds custom methods\n    for XYZ-specific functionality.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n    \"\"\"\n</code></pre>"},{"location":"developers/custom_computers/#testing","title":"Testing","text":"<p>Create comprehensive tests for your implementation:</p> <pre><code>def test_my_custom_computer():\n    computer = MyCustomComputer()\n    try:\n        # Test screenshot\n        screenshot = computer.get_screenshot()\n        assert screenshot is not None\n\n        # Test mouse move\n        result = computer.execute_mouse_move(MouseMoveAction(x=100, y=100))\n        assert result is True\n\n        # Test click\n        result = computer.execute_click(ClickAction(x=100, y=100))\n        assert result is True\n\n        # Test type\n        result = computer.execute_type(TypeAction(text=\"Hello, World!\"))\n        assert result is True\n    finally:\n        computer.close()\n</code></pre>"},{"location":"developers/custom_computers/#integration-with-commandlab","title":"Integration with CommandLAB","text":"<p>Once you've created your custom computer implementation, you can use it with the rest of the CommandLAB ecosystem:</p> <pre><code>from my_module import MyCustomComputer\nfrom commandLAB.types import ClickAction, TypeAction\n\n# Create an instance of your custom computer\ncomputer = MyCustomComputer(custom_param=\"value\")\n\n# Use it like any other computer\ncomputer.execute_click(ClickAction(x=100, y=100))\ncomputer.execute_type(TypeAction(text=\"Hello, CommandLAB!\"))\n\n# Use it with the gym framework\nfrom commandLAB.gym.environments.computer_env import ComputerEnv, ComputerEnvConfig\n\n# Create an environment with your custom computer\nenv = ComputerEnv(ComputerEnvConfig(\n    computer_cls_name=\"MyCustomComputer\",\n    computer_cls_kwargs={\"custom_param\": \"value\"}\n))\n</code></pre>"},{"location":"developers/custom_computers/#troubleshooting","title":"Troubleshooting","text":""},{"location":"developers/custom_computers/#common-issues","title":"Common Issues","text":"<ol> <li>Method Not Implemented: If you forget to implement a required method, you'll get a <code>NotImplementedError</code>.</li> </ol> <p>Solution: Implement all required methods from the <code>BaseComputer</code> interface.</p> <ol> <li>Type Errors: If your method returns the wrong type, you'll get a type error.</li> </ol> <p>Solution: Make sure your methods return the correct types as specified in the interface.</p> <ol> <li>Resource Leaks: If you don't properly clean up resources, you may experience resource leaks.</li> </ol> <p>Solution: Implement the <code>close</code> method to clean up all resources.</p>"},{"location":"developers/custom_computers/#debugging-tips","title":"Debugging Tips","text":"<ol> <li>Add logging to your implementation:</li> </ol> <pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\ndef execute_mouse_move(self, action: MouseMoveAction) -&gt; bool:\n    logger.debug(f\"Moving mouse to ({action.x}, {action.y})\")\n    # Implementation\n</code></pre> <ol> <li>Use a debugger to step through your code:</li> </ol> <pre><code>import pdb\n\ndef execute_command(self, action: CommandAction) -&gt; bool:\n    pdb.set_trace()  # Start the debugger\n    # Implementation\n</code></pre>"},{"location":"developers/custom_computers/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Creating Custom Provisioners</li> <li>Explore Creating Custom Agents</li> <li>Contribute your implementation to the CommandLAB project </li> </ul>"},{"location":"developers/provisioners/","title":"Provisioner System for Developers","text":"<p>This guide provides detailed information about the CommandLAB provisioner system for library developers who want to extend or modify the system.</p>"},{"location":"developers/provisioners/#architecture-overview","title":"Architecture Overview","text":"<p>The provisioner system is designed to handle the setup, management, and teardown of computer environments across various platforms. It follows a modular architecture with the following components:</p> <ol> <li>BaseComputerProvisioner: Abstract base class that defines the common interface for all provisioners</li> <li>Platform-specific Provisioners: Concrete implementations for different platforms (AWS, Azure, GCP, Docker, Kubernetes)</li> <li>Build System: Tools for building and packaging images for different platforms</li> </ol>"},{"location":"developers/provisioners/#basecomputerprovisioner-interface","title":"BaseComputerProvisioner Interface","text":"<p>All provisioners implement the <code>BaseComputerProvisioner</code> interface:</p> <pre><code>class BaseComputerProvisioner(ABC):\n    def __init__(self, port: int = 8000):\n        self.port = port\n\n    @abstractmethod\n    def setup(self) -&gt; None:\n        \"\"\"Setup the computer environment\"\"\"\n\n    @abstractmethod\n    def teardown(self) -&gt; None:\n        \"\"\"Cleanup resources\"\"\"\n\n    @abstractmethod\n    def is_running(self) -&gt; bool:\n        \"\"\"Check if the environment is running\"\"\"\n\n    def get_status(self) -&gt; str:\n        \"\"\"Get the current status of the provisioner\"\"\"\n        return self._status\n</code></pre>"},{"location":"developers/provisioners/#common-implementation-patterns","title":"Common Implementation Patterns","text":"<p>All provisioners follow these common implementation patterns:</p>"},{"location":"developers/provisioners/#status-tracking","title":"Status Tracking","text":"<p>Provisioners track their status using a <code>_status</code> field with these standard values: - <code>\"not_started\"</code>: Initial state - <code>\"starting\"</code>: During setup - <code>\"running\"</code>: Successfully running - <code>\"stopping\"</code>: During teardown - <code>\"stopped\"</code>: Successfully stopped - <code>\"error\"</code>: Error state</p>"},{"location":"developers/provisioners/#logging","title":"Logging","text":"<p>Provisioners use Python's standard logging module:</p> <pre><code>import logging\nlogger = logging.getLogger(__name__)\n\n# Usage\nlogger.info(\"Starting setup...\")\nlogger.error(f\"Error during setup: {e}\")\n</code></pre>"},{"location":"developers/provisioners/#error-handling","title":"Error Handling","text":"<p>Provisioners implement robust error handling with retry logic:</p> <pre><code>retry_count = 0\nwhile retry_count &lt; self.max_retries:\n    try:\n        # Setup logic\n        return\n    except Exception as e:\n        retry_count += 1\n        if retry_count &gt;= self.max_retries:\n            self._status = \"error\"\n            logger.error(f\"Failed after {self.max_retries} attempts: {e}\")\n            raise\n        logger.warning(f\"Error, retrying ({retry_count}/{self.max_retries}): {e}\")\n        time.sleep(2 ** retry_count)  # Exponential backoff\n</code></pre>"},{"location":"developers/provisioners/#timeouts","title":"Timeouts","text":"<p>Provisioners implement timeouts for long-running operations:</p> <pre><code>start_time = time.time()\nwhile time.time() - start_time &lt; self.timeout:\n    if self.is_running():\n        return True\n    time.sleep(5)\nraise TimeoutError(\"Operation timed out\")\n</code></pre>"},{"location":"developers/provisioners/#platform-specific-provisioners","title":"Platform-Specific Provisioners","text":""},{"location":"developers/provisioners/#aws-provisioner","title":"AWS Provisioner","text":"<p>The AWS provisioner uses boto3 to create and manage EC2 instances:</p> <pre><code>class AWSProvisioner(BaseComputerProvisioner):\n    def __init__(\n        self, \n        port: int = 8000, \n        region: str = \"us-west-2\", \n        instance_type: str = \"t2.micro\",\n        image_id: str = None,\n        security_groups: List[str] = None,\n        max_retries: int = 3,\n        timeout: int = 300\n    ):\n        # ...\n</code></pre> <p>Key implementation details: - Uses boto3 EC2 client - Configurable AMI ID and security groups - Implements retry logic and timeouts - Tracks instance state</p>"},{"location":"developers/provisioners/#azure-provisioner","title":"Azure Provisioner","text":"<p>The Azure provisioner uses the Azure SDK to create and manage VMs:</p> <pre><code>class AzureProvisioner(BaseComputerProvisioner):\n    def __init__(\n        self, \n        port: int = 8000, \n        resource_group: str = \"commandlab-rg\", \n        location: str = \"eastus\", \n        vm_size: str = \"Standard_DS1_v2\",\n        subscription_id: str = None, \n        image_id: str = None,\n        max_retries: int = 3, \n        timeout: int = 600\n    ):\n        # ...\n</code></pre> <p>Key implementation details: - Uses Azure Compute Management Client - Supports environment variable fallback for credentials - Configurable VM size and image ID</p>"},{"location":"developers/provisioners/#gcp-provisioner","title":"GCP Provisioner","text":"<p>The GCP provisioner uses the Google Cloud SDK to create and manage VMs:</p> <pre><code>class GCPProvisioner(BaseComputerProvisioner):\n    def __init__(\n        self, \n        port: int = 8000, \n        project: str = None, \n        zone: str = \"us-central1-a\", \n        machine_type: str = \"n1-standard-1\",\n        source_image: str = None,\n        max_retries: int = 3,\n        timeout: int = 600\n    ):\n        # ...\n</code></pre> <p>Key implementation details: - Uses Google Cloud Compute API - Configurable project, zone, and machine type - Configurable source image</p>"},{"location":"developers/provisioners/#docker-provisioner","title":"Docker Provisioner","text":"<p>The Docker provisioner supports multiple container platforms:</p> <pre><code>class DockerProvisioner(BaseComputerProvisioner):\n    def __init__(\n        self, \n        port: int = 8000, \n        container_name: str = \"commandlab-daemon\",\n        platform: DockerPlatform = DockerPlatform.LOCAL,\n        version: Optional[str] = None,\n        region: str = None,\n        resource_group: str = None,\n        project_id: str = None,\n        subnets: List[str] = None,\n        security_groups: List[str] = None,\n        subscription_id: str = None,\n        max_retries: int = 3,\n        timeout: int = 300\n    ):\n        # ...\n</code></pre> <p>Key implementation details: - Supports multiple platforms (LOCAL, AWS_ECS, AZURE_CONTAINER_INSTANCES, GCP_CLOUD_RUN) - Platform-specific setup and teardown methods - Configurable container name and version</p>"},{"location":"developers/provisioners/#kubernetes-provisioner","title":"Kubernetes Provisioner","text":"<p>The Kubernetes provisioner supports multiple Kubernetes platforms:</p> <pre><code>class KubernetesProvisioner(BaseComputerProvisioner):\n    def __init__(\n        self,\n        port: int = 8000,\n        platform: KubernetesPlatform = KubernetesPlatform.LOCAL,\n        namespace: str = \"default\",\n        cluster_name: Optional[str] = None,\n        region: Optional[str] = None,\n        resource_group: Optional[str] = None,\n        project_id: Optional[str] = None,\n        version: Optional[str] = None,\n        max_retries: int = 3,\n        timeout: int = 300\n    ):\n        # ...\n</code></pre> <p>Key implementation details: - Supports multiple platforms (LOCAL, AWS_EKS, AZURE_AKS, GCP_GKE) - Creates Kubernetes deployments and services - Configurable namespace and cluster</p>"},{"location":"developers/provisioners/#build-system","title":"Build System","text":"<p>The build system is responsible for creating images for different platforms:</p>"},{"location":"developers/provisioners/#build-images-cli","title":"Build Images CLI","text":"<p>The <code>build_images.py</code> script provides a CLI for building images:</p> <pre><code>cli = typer.Typer(help=\"Build CommandLAB daemon images for different platforms\")\n\n@cli.command()\ndef build_docker_image(version: Optional[str] = ...):\n    \"\"\"Build the Docker image for the daemon\"\"\"\n    # ...\n\n@cli.command()\ndef build_aws_ami(version: Optional[str] = ...):\n    \"\"\"Build AWS AMI using Packer\"\"\"\n    # ...\n\n@cli.command()\ndef build_azure_vm(version: Optional[str] = ...):\n    \"\"\"Build Azure VM image using Packer\"\"\"\n    # ...\n\n@cli.command()\ndef build_gcp_vm(version: Optional[str] = ...):\n    \"\"\"Build GCP VM image using Packer\"\"\"\n    # ...\n\n@cli.command()\ndef build_kubernetes_image(version: Optional[str] = ...):\n    \"\"\"Build Docker image for Kubernetes deployment\"\"\"\n    # ...\n\n@cli.command()\ndef build_all_images(version: Optional[str] = ...):\n    \"\"\"Build images for all platforms\"\"\"\n    # ...\n</code></pre>"},{"location":"developers/provisioners/#packer-templates","title":"Packer Templates","text":"<p>The build system automatically generates Packer templates for cloud platforms:</p> <ul> <li>AWS AMI template</li> <li>Azure VM template</li> <li>GCP VM template</li> </ul> <p>These templates define how to build the images with the necessary dependencies.</p>"},{"location":"developers/provisioners/#extending-the-provisioner-system","title":"Extending the Provisioner System","text":""},{"location":"developers/provisioners/#creating-a-new-provisioner","title":"Creating a New Provisioner","text":"<p>To create a new provisioner:</p> <ol> <li>Create a new class that inherits from <code>BaseComputerProvisioner</code></li> <li>Implement the required methods: <code>setup()</code>, <code>teardown()</code>, and <code>is_running()</code></li> <li>Follow the common implementation patterns for status tracking, logging, error handling, and timeouts</li> </ol> <p>Example:</p> <pre><code>class MyCustomProvisioner(BaseComputerProvisioner):\n    def __init__(self, port: int = 8000, custom_param: str = \"default\"):\n        super().__init__(port)\n        self.custom_param = custom_param\n        self._status = \"not_started\"\n\n    def setup(self) -&gt; None:\n        self._status = \"starting\"\n        # Implementation...\n        self._status = \"running\"\n\n    def teardown(self) -&gt; None:\n        self._status = \"stopping\"\n        # Implementation...\n        self._status = \"stopped\"\n\n    def is_running(self) -&gt; bool:\n        # Implementation...\n        return True\n</code></pre>"},{"location":"developers/provisioners/#adding-build-support-for-a-new-platform","title":"Adding Build Support for a New Platform","text":"<p>To add build support for a new platform:</p> <ol> <li>Add a new command to <code>build_images.py</code></li> <li>Implement the build logic for the new platform</li> <li>Add the new command to <code>build_all_images()</code></li> </ol> <p>Example:</p> <pre><code>@cli.command()\ndef build_my_platform(version: Optional[str] = ...):\n    \"\"\"Build image for my platform\"\"\"\n    # Implementation...\n\n# Update build_all_images\n@cli.command()\ndef build_all_images(version: Optional[str] = ...):\n    # Existing code...\n    logger.info(\"Building My Platform image...\")\n    build_my_platform(version)\n    # Rest of existing code...\n</code></pre>"},{"location":"developers/provisioners/#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling: Always implement robust error handling with retry logic</li> <li>Logging: Use the standard logging module with appropriate log levels</li> <li>Timeouts: Implement timeouts for all long-running operations</li> <li>Status Tracking: Use the standard status values for consistency</li> <li>Configuration: Make all platform-specific parameters configurable</li> <li>Resource Cleanup: Ensure proper cleanup in the <code>teardown()</code> method</li> <li>Validation: Validate required parameters in the constructor</li> </ol> <p>By following these guidelines, you can create robust and maintainable provisioners that integrate seamlessly with the CommandLAB ecosystem. </p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the CommandLAB tutorials section! These step-by-step guides will help you learn how to use CommandLAB for various automation tasks.</p>"},{"location":"tutorials/#getting-started","title":"Getting Started","text":"<p>These tutorials cover the basics of CommandLAB:</p> <ul> <li>Basic Automation - Learn how to automate a simple text editing task</li> <li>Local Computer Control - Control your local computer with CommandLAB</li> <li>Remote Control - Control a remote computer using the daemon</li> </ul>"},{"location":"tutorials/#advanced","title":"Advanced","text":"<p>These tutorials cover more advanced topics:</p> <ul> <li>Training Agents - Train AI agents to use computers</li> <li>Cloud Deployment - Deploy CommandLAB in cloud environments</li> <li>Provisioner Usage - Use provisioners to manage computer environments</li> <li>Custom Agents - Create your own AI agents</li> <li>Custom Computers - Implement custom computer backends</li> <li>Custom Provisioners - Create custom provisioning solutions</li> <li>CI/CD Integration - Integrate CommandLAB into CI/CD pipelines</li> <li>Multi-Agent Systems - Create systems with multiple agents</li> <li>Distributed Automation - Run automation tasks across multiple machines</li> </ul>"},{"location":"tutorials/#examples","title":"Examples","text":"<p>Real-world examples of CommandLAB in action:</p> <ul> <li>Web Automation - Automate web browsing and form filling</li> <li>Desktop Application Automation - Automate desktop applications</li> <li>File Management Automation - Automate file operations</li> <li>Text Processing Automation - Automate text editing and processing</li> <li>Automated Testing - Use CommandLAB for UI testing</li> <li>Data Collection - Collect data from applications and websites</li> <li>Process Automation - Automate business processes</li> </ul>"},{"location":"tutorials/#tutorial-structure","title":"Tutorial Structure","text":"<p>Each tutorial follows a consistent structure:</p> <ol> <li>Introduction - What you'll learn and why it's useful</li> <li>Prerequisites - What you need to know and have installed</li> <li>Step-by-Step Instructions - Detailed instructions with code examples</li> <li>Explanation - Why things work the way they do</li> <li>Exercises - Optional exercises to reinforce learning</li> <li>Next Steps - Suggestions for what to learn next</li> </ol>"},{"location":"tutorials/#contributing-tutorials","title":"Contributing Tutorials","text":"<p>We welcome contributions to our tutorials! If you've created a useful automation with CommandLAB, consider sharing it as a tutorial. See our contribution guidelines for more information.</p>"},{"location":"tutorials/#requesting-tutorials","title":"Requesting Tutorials","text":"<p>If you'd like to see a tutorial on a specific topic, please open an issue on our GitHub repository with the label \"tutorial request\". </p>"},{"location":"tutorials/advanced/cloud-deployment/","title":"Running CommandLAB in the Cloud","text":"<p>This guide helps you run CommandLAB daemons in various cloud container services without needing to manage full VMs.</p>"},{"location":"tutorials/advanced/cloud-deployment/#quick-start","title":"Quick Start","text":""},{"location":"tutorials/advanced/cloud-deployment/#aws-ecs-elastic-container-service","title":"AWS ECS (Elastic Container Service)","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.computers.provisioners.docker_provisioner import DockerPlatform\n\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER,\n    platform=DockerPlatform.AWS_ECS,\n    region=\"us-west-2\"\n)\n</code></pre>"},{"location":"tutorials/advanced/cloud-deployment/#azure-container-instances","title":"Azure Container Instances","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.computers.provisioners.docker_provisioner import DockerPlatform\n\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER,\n    platform=DockerPlatform.AZURE_CONTAINER_INSTANCES,\n    resource_group=\"my-resource-group\",\n    region=\"eastus\"\n)\n</code></pre>"},{"location":"tutorials/advanced/cloud-deployment/#google-cloud-run","title":"Google Cloud Run","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.computers.provisioners.docker_provisioner import DockerPlatform\n\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER,\n    platform=DockerPlatform.GCP_CLOUD_RUN,\n    project_id=\"my-project\",\n    region=\"us-central1\"\n)\n</code></pre>"},{"location":"tutorials/advanced/cloud-deployment/#managed-kubernetes-services","title":"Managed Kubernetes Services","text":""},{"location":"tutorials/advanced/cloud-deployment/#amazon-eks","title":"Amazon EKS","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.computers.provisioners.kubernetes_provisioner import KubernetesPlatform\n\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.KUBERNETES,\n    platform=KubernetesPlatform.AWS_EKS,\n    cluster_name=\"my-cluster\",\n    region=\"us-west-2\"\n)\n</code></pre>"},{"location":"tutorials/advanced/cloud-deployment/#azure-aks","title":"Azure AKS","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.computers.provisioners.kubernetes_provisioner import KubernetesPlatform\n\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.KUBERNETES,\n    platform=KubernetesPlatform.AZURE_AKS,\n    cluster_name=\"my-cluster\",\n    resource_group=\"my-resource-group\"\n)\n</code></pre>"},{"location":"tutorials/advanced/cloud-deployment/#google-gke","title":"Google GKE","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.computers.provisioners.kubernetes_provisioner import KubernetesPlatform\n\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.KUBERNETES,\n    platform=KubernetesPlatform.GCP_GKE,\n    cluster_name=\"my-cluster\",\n    project_id=\"my-project\",\n    region=\"us-central1\"\n)\n</code></pre>"},{"location":"tutorials/advanced/cloud-deployment/#cost-considerations","title":"Cost Considerations","text":"<ul> <li>AWS ECS with Fargate: Pay only for resources used</li> <li>Azure Container Instances: Per-second billing</li> <li>Google Cloud Run: Pay-per-use pricing</li> <li>Managed Kubernetes: Additional cluster management costs</li> </ul>"},{"location":"tutorials/advanced/cloud-deployment/#best-practices","title":"Best Practices","text":"<ol> <li>Right-size your resources: Choose appropriate CPU and memory settings</li> <li>Clean up resources: Always call <code>computer.close()</code> when done</li> <li>Monitor usage and costs: Set up billing alerts</li> <li>Use auto-scaling: Configure scaling policies for variable workloads</li> <li>Consider regional pricing: Choose regions with lower costs when possible</li> </ol>"},{"location":"tutorials/advanced/cloud-deployment/#security-considerations","title":"Security Considerations","text":"<ol> <li>API Token Security: Store API tokens securely</li> <li>Network Access: Limit network exposure of your daemon</li> <li>IAM Permissions: Use least-privilege permissions</li> <li>Image Security: Scan container images for vulnerabilities</li> <li>Data Protection: Be careful with sensitive data in containers</li> </ol>"},{"location":"tutorials/advanced/cloud-deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/advanced/cloud-deployment/#common-issues","title":"Common Issues","text":"<ul> <li>Connection Timeouts: Check network connectivity and security groups</li> <li>Authentication Failures: Verify credentials and API tokens</li> <li>Resource Limits: Check if you've hit quota limits</li> <li>Image Pull Errors: Ensure your container registry is accessible</li> </ul>"},{"location":"tutorials/advanced/cloud-deployment/#debugging","title":"Debugging","text":"<p>```python import logging logging.basicConfig(level=logging.DEBUG)</p>"},{"location":"tutorials/advanced/cloud-deployment/#create-computer-with-debug-logging","title":"Create computer with debug logging","text":"<p>computer = DaemonClientComputer(     provisioning_method=ProvisioningMethod.DOCKER,     platform=DockerPlatform.AWS_ECS,     region=\"us-west-2\" ) </p>"},{"location":"tutorials/advanced/provisioner-usage/","title":"Using Provisioners in CommandLAB","text":"<p>Provisioners in CommandLAB allow you to automatically set up and manage computer environments across different platforms. This guide explains how to use provisioners in your projects.</p>"},{"location":"tutorials/advanced/provisioner-usage/#what-are-provisioners","title":"What are Provisioners?","text":"<p>Provisioners handle the lifecycle of computer environments:</p> <ol> <li>Setup: Creating and configuring the environment</li> <li>Status Checking: Monitoring the environment's state</li> <li>Teardown: Cleaning up resources when they're no longer needed</li> </ol> <p>This allows you to work with ephemeral environments that can be created and destroyed as needed.</p>"},{"location":"tutorials/advanced/provisioner-usage/#available-provisioners","title":"Available Provisioners","text":"<p>CommandLAB includes provisioners for various platforms:</p>"},{"location":"tutorials/advanced/provisioner-usage/#local-docker","title":"Local Docker","text":"<p>Run environments in Docker containers on your local machine:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.computers.provisioners.docker_provisioner import DockerPlatform\n\n# Create a computer with local Docker provisioning\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER,\n    platform=DockerPlatform.LOCAL\n)\n\n# Use the computer\n# ...\n\n# Clean up when done\ncomputer.close()  # Stops and removes the container\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#aws","title":"AWS","text":"<p>Run environments in AWS EC2 instances:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\n# Create a computer with AWS provisioning\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.AWS,\n    region=\"us-west-2\",\n    instance_type=\"t2.micro\",\n    image_id=\"ami-0123456789abcdef0\",  # Optional: custom AMI ID\n    security_groups=[\"my-security-group\"]  # Optional: custom security groups\n)\n\n# Use the computer\n# ...\n\n# Clean up when done\ncomputer.close()  # Terminates the EC2 instance\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#azure","title":"Azure","text":"<p>Run environments in Azure VMs:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\n# Create a computer with Azure provisioning\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.AZURE,\n    resource_group=\"my-resource-group\",\n    location=\"eastus\",\n    vm_size=\"Standard_DS1_v2\",\n    subscription_id=\"your-subscription-id\",  # Optional: can use AZURE_SUBSCRIPTION_ID env var\n    image_id=\"your-image-id\"  # Optional: custom image ID\n)\n\n# Use the computer\n# ...\n\n# Clean up when done\ncomputer.close()  # Deletes the Azure VM\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#google-cloud-platform","title":"Google Cloud Platform","text":"<p>Run environments in GCP VMs:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\n# Create a computer with GCP provisioning\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.GCP,\n    project=\"your-project-id\",\n    zone=\"us-central1-a\",\n    machine_type=\"n1-standard-1\",\n    source_image=\"your-image-id\"  # Optional: custom image ID\n)\n\n# Use the computer\n# ...\n\n# Clean up when done\ncomputer.close()  # Deletes the GCP VM\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#kubernetes","title":"Kubernetes","text":"<p>Run environments in Kubernetes clusters:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.computers.provisioners.kubernetes_provisioner import KubernetesPlatform\n\n# Create a computer with Kubernetes provisioning\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.KUBERNETES,\n    platform=KubernetesPlatform.GCP_GKE,  # Or AWS_EKS, AZURE_AKS, LOCAL\n    namespace=\"my-namespace\",\n    cluster_name=\"my-cluster\",\n    project_id=\"my-project\",  # For GCP_GKE\n    region=\"us-central1\"  # For AWS_EKS and GCP_GKE\n)\n\n# Use the computer\n# ...\n\n# Clean up when done\ncomputer.close()  # Deletes the Kubernetes resources\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#container-services","title":"Container Services","text":"<p>Run environments in managed container services:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.computers.provisioners.docker_provisioner import DockerPlatform\n\n# AWS ECS\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER,\n    platform=DockerPlatform.AWS_ECS,\n    region=\"us-west-2\",\n    subnets=[\"subnet-12345\"],\n    security_groups=[\"sg-12345\"]\n)\n\n# Azure Container Instances\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER,\n    platform=DockerPlatform.AZURE_CONTAINER_INSTANCES,\n    region=\"eastus\",\n    resource_group=\"my-resource-group\",\n    subscription_id=\"your-subscription-id\"\n)\n\n# Google Cloud Run\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER,\n    platform=DockerPlatform.GCP_CLOUD_RUN,\n    project_id=\"your-project-id\",\n    region=\"us-central1\"\n)\n\n# Use the computer\n# ...\n\n# Clean up when done\ncomputer.close()\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"tutorials/advanced/provisioner-usage/#timeouts-and-retries","title":"Timeouts and Retries","text":"<p>You can configure timeouts and retry behavior:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.AWS,\n    region=\"us-west-2\",\n    max_retries=5,  # Default: 3\n    timeout=600     # Default: 300 (5 minutes)\n)\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#status-checking","title":"Status Checking","text":"<p>You can check the status of a provisioner:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER\n)\n\n# Get the provisioner status\nstatus = computer.provisioner.get_status()\nprint(f\"Provisioner status: {status}\")\n# Possible values: \"not_started\", \"starting\", \"running\", \"stopping\", \"stopped\", \"error\"\n\n# Check if the environment is running\nis_running = computer.provisioner.is_running()\nprint(f\"Is running: {is_running}\")\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/advanced/provisioner-usage/#resource-management","title":"Resource Management","text":"<p>Always clean up resources when you're done:</p> <pre><code>try:\n    computer = DaemonClientComputer(provisioning_method=ProvisioningMethod.AWS)\n    # Use the computer\nfinally:\n    computer.close()  # Ensure resources are cleaned up\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#error-handling","title":"Error Handling","text":"<p>Handle potential errors during provisioning:</p> <pre><code>try:\n    computer = DaemonClientComputer(provisioning_method=ProvisioningMethod.AWS)\n    # Use the computer\nexcept Exception as e:\n    print(f\"Error during provisioning: {e}\")\n    # Handle the error\nfinally:\n    if 'computer' in locals():\n        computer.close()\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#environment-variables","title":"Environment Variables","text":"<p>Use environment variables for sensitive information:</p> <pre><code># Set environment variables\nimport os\nos.environ[\"AZURE_SUBSCRIPTION_ID\"] = \"your-subscription-id\"\nos.environ[\"AZURE_CLIENT_ID\"] = \"your-client-id\"\nos.environ[\"AZURE_CLIENT_SECRET\"] = \"your-client-secret\"\nos.environ[\"AZURE_TENANT_ID\"] = \"your-tenant-id\"\n\n# Create computer without explicitly passing credentials\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.AZURE,\n    resource_group=\"my-resource-group\"\n)\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/advanced/provisioner-usage/#common-issues","title":"Common Issues","text":"<ol> <li>Connection Timeouts: Check network connectivity and security groups/firewall rules.</li> <li>Authentication Errors: Verify your credentials and permissions.</li> <li>Resource Limits: Check if you've reached your cloud provider's resource limits.</li> <li>Image Not Found: Ensure the specified image ID exists and is accessible.</li> </ol>"},{"location":"tutorials/advanced/provisioner-usage/#logging","title":"Logging","text":"<p>Enable detailed logging for troubleshooting:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre>"},{"location":"tutorials/advanced/provisioner-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Cloud Containers for more advanced cloud deployment options</li> <li>Explore Computers to understand how to interact with provisioned environments</li> <li>Check out the Daemon documentation to learn about the remote control protocol </li> </ul>"},{"location":"tutorials/advanced/training-agents/","title":"Training Agents Tutorial","text":"<p>This tutorial will guide you through the process of training AI agents to use computers with CommandLAB's gym framework. You'll learn how to set up environments, create agents, and train them to perform tasks.</p>"},{"location":"tutorials/advanced/training-agents/#introduction","title":"Introduction","text":"<p>CommandLAB's gym framework is inspired by OpenAI Gym and provides a standardized interface for training agents to use computers. This allows you to:</p> <ul> <li>Train agents to automate UI interactions</li> <li>Evaluate agent performance on specific tasks</li> <li>Compare different agent implementations</li> <li>Create benchmarks for computer-using AI</li> </ul>"},{"location":"tutorials/advanced/training-agents/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>CommandLAB installed with gym and local computer support:   <pre><code>pip install \"commandlab[local,gym]\"\n</code></pre></li> <li>For vision-language models, you'll need an API key for OpenAI, Anthropic, or another supported provider</li> </ul>"},{"location":"tutorials/advanced/training-agents/#step-1-understanding-the-gym-framework","title":"Step 1: Understanding the Gym Framework","text":"<p>The CommandLAB gym framework consists of several key components:</p> <ul> <li>Environments: Define the task and interface with computers</li> <li>Agents: Make decisions based on observations</li> <li>Drivers: Manage the interaction between agents and environments</li> <li>Episodes: Sequences of interactions between agents and environments</li> <li>Trainers: Train agents using episodes</li> </ul> <p>The basic flow is:</p> <ol> <li>The environment provides an observation (e.g., a screenshot)</li> <li>The agent selects an action based on the observation</li> <li>The environment executes the action and returns a new observation, reward, and done flag</li> <li>The process repeats until the episode is complete</li> </ol>"},{"location":"tutorials/advanced/training-agents/#step-2-setting-up-an-environment","title":"Step 2: Setting Up an Environment","text":"<p>Let's start by setting up a simple environment using a local computer:</p> <pre><code>from commandLAB.gym.environments.computer_env import ComputerEnv, ComputerEnvConfig\n\n# Configure the environment\nconfig = ComputerEnvConfig(\n    computer_cls_name=\"LocalPynputComputer\",  # Use local computer with pynput\n    on_reset_python=\"echo 'Environment reset'\"  # Command to run on reset\n)\n\n# Create the environment\nenv = ComputerEnv(config)\n\n# Reset the environment to get the initial observation\nobservation = env.reset()\n</code></pre>"},{"location":"tutorials/advanced/training-agents/#step-3-creating-a-simple-agent","title":"Step 3: Creating a Simple Agent","text":"<p>Now, let's create a simple agent that uses a vision-language model to make decisions:</p> <pre><code>from commandLAB.gym.agents.naive_vision_language_computer_agent import NaiveComputerAgent\n\n# Create an agent with OpenAI's GPT-4 Vision\nagent = NaiveComputerAgent(chat_model_options={\n    \"model_provider\": \"openai\",\n    \"model\": \"gpt-4-vision-preview\",\n    \"api_key\": \"your-openai-api-key\"  # Replace with your actual API key\n})\n</code></pre>"},{"location":"tutorials/advanced/training-agents/#step-4-running-an-episode","title":"Step 4: Running an Episode","text":"<p>Let's use a driver to run an episode with our agent and environment:</p> <pre><code>from commandLAB.gym.drivers import SimpleDriver\n\n# Create a driver\ndriver = SimpleDriver(env=env, agent=agent)\n\n# Collect an episode\nepisode = driver.collect_episode()\n\n# Print episode statistics\nprint(f\"Episode length: {episode.num_steps}\")\nprint(f\"Total reward: {sum(step.reward for step in episode)}\")\n</code></pre>"},{"location":"tutorials/advanced/training-agents/#step-5-analyzing-the-episode","title":"Step 5: Analyzing the Episode","text":"<p>Let's analyze what happened during the episode:</p> <pre><code># Iterate through the steps in the episode\nfor i, step in enumerate(episode):\n    print(f\"Step {i+1}:\")\n    print(f\"  Action: {step.action}\")\n    print(f\"  Reward: {step.reward}\")\n    print(f\"  Info: {step.info}\")\n</code></pre>"},{"location":"tutorials/advanced/training-agents/#step-6-training-an-agent","title":"Step 6: Training an Agent","text":"<p>Now, let's train an agent using multiple episodes:</p> <pre><code>from commandLAB.gym.trainer import OnlineTrainer\n\n# Create a trainer\ntrainer = OnlineTrainer(driver=driver, agent=agent)\n\n# Train the agent for 10 episodes\nepisodes = trainer.train(num_episodes=10)\n\n# Print training statistics\nprint(trainer.get_training_stats())\n</code></pre>"},{"location":"tutorials/advanced/training-agents/#step-7-saving-and-loading-agents","title":"Step 7: Saving and Loading Agents","text":"<p>You can save and load trained agents:</p> <pre><code>import pickle\n\n# Save the agent\nwith open(\"trained_agent.pkl\", \"wb\") as f:\n    pickle.dump(agent, f)\n\n# Load the agent\nwith open(\"trained_agent.pkl\", \"rb\") as f:\n    loaded_agent = pickle.load(f)\n</code></pre>"},{"location":"tutorials/advanced/training-agents/#complete-example-training-an-agent-to-use-a-calculator","title":"Complete Example: Training an Agent to Use a Calculator","text":"<p>Here's a complete example that trains an agent to use the Windows calculator:</p> <pre><code>import time\nfrom commandLAB.gym.environments.computer_env import ComputerEnv, ComputerEnvConfig\nfrom commandLAB.gym.agents.naive_vision_language_computer_agent import NaiveComputerAgent\nfrom commandLAB.gym.drivers import SimpleDriver\nfrom commandLAB.types import CommandAction\n\n# Define a custom environment with a specific reward function\nclass CalculatorEnv(ComputerEnv):\n    def __init__(self):\n        super().__init__(ComputerEnvConfig(\n            computer_cls_name=\"LocalPynputComputer\",\n            on_reset_python=\"start calc\",  # Start calculator on reset\n            on_stop_python=\"taskkill /f /im calculator.exe\"  # Kill calculator on stop\n        ))\n        self.target_result = 42\n        self.current_result = 0\n\n    def get_reward(self, action):\n        # Extract the current result from the calculator display\n        # This is a simplified example - in a real implementation,\n        # you would use OCR to extract the number from the screenshot\n        screenshot = self._computer.get_screenshot()\n        # ... OCR logic to extract result ...\n\n        # For this example, we'll just simulate it\n        if isinstance(action.command, CommandAction):\n            if \"=\" in action.command.command:\n                # Simulate calculating the result\n                self.current_result = eval(action.command.command.split(\"=\")[0])\n\n        # Calculate reward based on how close we are to the target\n        distance = abs(self.current_result - self.target_result)\n        reward = 1.0 / (1.0 + distance)\n\n        # Bonus reward for exact match\n        if self.current_result == self.target_result:\n            reward += 10.0\n\n        return reward\n\n    def get_done(self, action):\n        # Episode is done if we reach the target or after 20 steps\n        return self.current_result == self.target_result or self.num_steps &gt;= 20\n\n# Create the environment\nenv = CalculatorEnv()\n\n# Create an agent\nagent = NaiveComputerAgent(chat_model_options={\n    \"model_provider\": \"openai\",\n    \"model\": \"gpt-4-vision-preview\",\n    \"api_key\": \"your-openai-api-key\"  # Replace with your actual API key\n})\n\n# Create a driver\ndriver = SimpleDriver(env=env, agent=agent)\n\n# Train the agent\ntrainer = OnlineTrainer(driver=driver, agent=agent)\nepisodes = trainer.train(num_episodes=5)\n\n# Print training statistics\nprint(trainer.get_training_stats())\n\n# Test the trained agent\nobservation = env.reset()\ndone = False\ntotal_reward = 0\n\nwhile not done:\n    action = agent.act(observation)\n    observation, reward, done, info = env.step(action)\n    total_reward += reward\n\nprint(f\"Test episode complete. Total reward: {total_reward}\")\n</code></pre>"},{"location":"tutorials/advanced/training-agents/#advanced-custom-agents","title":"Advanced: Custom Agents","text":"<p>You can create custom agents by implementing the <code>BaseComputerAgent</code> interface:</p> <pre><code>from commandLAB.gym.agents.base_agent import BaseComputerAgent\nfrom commandLAB.types import ComputerObservation, ComputerAction, ClickAction\n\nclass MyCustomAgent(BaseComputerAgent):\n    def reset(self):\n        \"\"\"Reset agent state\"\"\"\n        self.total_reward = 0.0\n\n    def act(self, observation: ComputerObservation) -&gt; ComputerAction:\n        \"\"\"Given an observation, determine the next action\"\"\"\n        # Simple agent that always clicks in the center of the screen\n        screenshot = observation.screenshot\n        if screenshot:\n            # Get the dimensions of the screenshot\n            # In a real implementation, you would parse the base64 image\n            width, height = 1920, 1080  # Placeholder values\n\n            # Click in the center\n            return ComputerAction(\n                click=ClickAction(x=width//2, y=height//2)\n            )\n        return None\n\n    def update(self, reward: float):\n        \"\"\"Update agent state based on reward\"\"\"\n        self.total_reward += reward\n\n    def train(self, episodes: list):\n        \"\"\"Train the agent on episodes\"\"\"\n        # Training logic here\n        pass\n</code></pre>"},{"location":"tutorials/advanced/training-agents/#advanced-custom-environments","title":"Advanced: Custom Environments","text":"<p>You can create custom environments by extending the <code>ComputerEnv</code> class:</p> <pre><code>from commandLAB.gym.environments.computer_env import ComputerEnv, ComputerEnvConfig\nfrom commandLAB.types import ComputerAction\n\nclass WebBrowserEnv(ComputerEnv):\n    def __init__(self, url=\"https://www.google.com\"):\n        super().__init__(ComputerEnvConfig(\n            computer_cls_name=\"LocalPynputComputer\",\n            on_reset_python=f\"start chrome {url}\",\n            on_stop_python=\"taskkill /f /im chrome.exe\"\n        ))\n        self.target_text = \"CommandLAB\"\n\n    def get_reward(self, action: ComputerAction) -&gt; float:\n        \"\"\"Custom reward function based on whether the target text is visible\"\"\"\n        screenshot = self._computer.get_screenshot()\n        # Use OCR to check if target text is visible\n        # For this example, we'll just return a placeholder reward\n        return 1.0\n\n    def get_done(self, action: ComputerAction) -&gt; bool:\n        \"\"\"Episode is done when target text is found or max steps reached\"\"\"\n        return self.num_steps &gt;= 20\n</code></pre>"},{"location":"tutorials/advanced/training-agents/#advanced-distributed-training","title":"Advanced: Distributed Training","text":"<p>For large-scale training, you can use the <code>MultiprocessDriver</code>:</p> <pre><code>from commandLAB.gym.drivers import MultiprocessDriver\nfrom commandLAB.gym.trainer import BatchTrainer\n\n# Create a multiprocess driver with 4 workers\ndriver = MultiprocessDriver(env=env, agent=agent, max_workers=4)\n\n# Create a batch trainer\ntrainer = BatchTrainer(driver=driver, agent=agent, batch_size=10)\n\n# Train the agent for 100 episodes\nepisodes = trainer.train(num_episodes=100)\n</code></pre>"},{"location":"tutorials/advanced/training-agents/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/advanced/training-agents/#agent-not-learning","title":"Agent Not Learning","text":"<p>If your agent isn't learning:</p> <ol> <li>Check Reward Function: Make sure your reward function provides meaningful feedback</li> <li>Increase Episode Length: Allow more steps per episode</li> <li>Adjust Learning Rate: If using a learning-based agent, adjust the learning rate</li> <li>Improve Observations: Make sure the agent has enough information to make decisions</li> </ol>"},{"location":"tutorials/advanced/training-agents/#performance-issues","title":"Performance Issues","text":"<p>If you're experiencing performance issues:</p> <ol> <li>Reduce Screenshot Size: Use smaller screenshots to reduce memory usage</li> <li>Optimize Reward Function: Make sure your reward function is efficient</li> <li>Use Threaded Driver: Use <code>ThreadedDriver</code> for better performance</li> <li>Limit API Calls: If using an API-based model, limit the number of calls</li> </ol>"},{"location":"tutorials/advanced/training-agents/#exercises","title":"Exercises","text":"<ol> <li>Calculator Agent: Train an agent to perform calculations on a calculator app</li> <li>Web Navigation: Train an agent to navigate a website and find specific information</li> <li>Text Editor: Train an agent to open a text editor and write a specific message</li> <li>Custom Agent: Implement a custom agent using a different vision-language model</li> </ol>"},{"location":"tutorials/advanced/training-agents/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Vision-Language Models</li> <li>Explore Reinforcement Learning</li> <li>Try the Custom Agents Guide </li> </ul>"},{"location":"tutorials/getting-started/basic-automation/","title":"Basic Automation Tutorial","text":"<p>In this tutorial, we'll create a simple automation script using CommandLAB to open a text editor, type some text, and save a file.</p>"},{"location":"tutorials/getting-started/basic-automation/#prerequisites","title":"Prerequisites","text":"<ul> <li>CommandLAB installed with local backend: <code>pip install commandlab[local]</code></li> <li>A text editor (like Notepad on Windows or TextEdit on macOS)</li> </ul>"},{"location":"tutorials/getting-started/basic-automation/#step-1-import-required-modules","title":"Step 1: Import Required Modules","text":"<pre><code>from commandLAB.computers.local_pynput_computer import LocalPynputComputer\nfrom commandLAB.types import (\n    CommandAction,\n    TypeAction,\n    ClickAction,\n    KeyboardHotkeyAction,\n    KeyboardKey,\n    KeyboardKeyPressAction\n)\nimport os\nimport time\n</code></pre>"},{"location":"tutorials/getting-started/basic-automation/#step-2-create-a-computer-instance","title":"Step 2: Create a Computer Instance","text":"<pre><code># Create a computer instance\ncomputer = LocalPynputComputer()\n\n# Give yourself time to switch to the right window\nprint(\"Starting in 3 seconds...\")\ntime.sleep(3)\n</code></pre>"},{"location":"tutorials/getting-started/basic-automation/#step-3-open-the-text-editor","title":"Step 3: Open the Text Editor","text":"<pre><code># Open text editor (Notepad on Windows, TextEdit on macOS)\nif computer.execute_command(CommandAction(command=\"notepad\" if os.name == \"nt\" else \"open -a TextEdit\")):\n    print(\"Opened text editor\")\n    # Wait for it to open\n    time.sleep(2)\nelse:\n    print(\"Failed to open text editor\")\n    exit(1)\n</code></pre>"},{"location":"tutorials/getting-started/basic-automation/#step-4-type-some-text","title":"Step 4: Type Some Text","text":"<pre><code># Type some text\ncomputer.execute_type(TypeAction(text=\"Hello from CommandLAB!\\n\\nThis file was created automatically.\"))\nprint(\"Typed text\")\n</code></pre>"},{"location":"tutorials/getting-started/basic-automation/#step-5-save-the-file","title":"Step 5: Save the File","text":"<pre><code># Press Ctrl+S to save\ncomputer.execute_keyboard_hotkey(KeyboardHotkeyAction(keys=[KeyboardKey.CTRL, KeyboardKey.S]))\nprint(\"Pressed Ctrl+S\")\ntime.sleep(1)\n\n# Type the filename\ncomputer.execute_type(TypeAction(text=\"commandlab_example.txt\"))\nprint(\"Entered filename\")\ntime.sleep(1)\n\n# Press Enter to confirm\ncomputer.execute_keyboard_key_press(KeyboardKeyPressAction(key=KeyboardKey.ENTER))\nprint(\"Saved file\")\ntime.sleep(1)\n</code></pre>"},{"location":"tutorials/getting-started/basic-automation/#step-6-close-the-editor","title":"Step 6: Close the Editor","text":"<pre><code># Press Alt+F4 to close\ncomputer.execute_keyboard_hotkey(KeyboardHotkeyAction(keys=[KeyboardKey.ALT, KeyboardKey.F4]))\nprint(\"Closed editor\")\n</code></pre>"},{"location":"tutorials/getting-started/basic-automation/#complete-script","title":"Complete Script","text":"<p>Here's the complete script:</p> <pre><code>import os\nimport time\nfrom commandLAB.computers.local_pynput_computer import LocalPynputComputer\nfrom commandLAB.types import (\n    CommandAction,\n    TypeAction,\n    KeyboardHotkeyAction,\n    KeyboardKey,\n    KeyboardKeyPressAction\n)\n\n# Create a computer instance\ncomputer = LocalPynputComputer()\n\n# Give yourself time to switch to the right window\nprint(\"Starting in 3 seconds...\")\ntime.sleep(3)\n\n# Open text editor\nif computer.execute_command(CommandAction(command=\"notepad\" if os.name == \"nt\" else \"open -a TextEdit\")):\n    print(\"Opened text editor\")\n    # Wait for it to open\n    time.sleep(2)\nelse:\n    print(\"Failed to open text editor\")\n    exit(1)\n\n# Type some text\ncomputer.execute_type(TypeAction(text=\"Hello from CommandLAB!\\n\\nThis file was created automatically.\"))\nprint(\"Typed text\")\n\n# Press Ctrl+S to save\ncomputer.execute_keyboard_hotkey(KeyboardHotkeyAction(keys=[KeyboardKey.CTRL, KeyboardKey.S]))\nprint(\"Pressed Ctrl+S\")\ntime.sleep(1)\n\n# Type the filename\ncomputer.execute_type(TypeAction(text=\"commandlab_example.txt\"))\nprint(\"Entered filename\")\ntime.sleep(1)\n\n# Press Enter to confirm\ncomputer.execute_keyboard_key_press(KeyboardKeyPressAction(key=KeyboardKey.ENTER))\nprint(\"Saved file\")\ntime.sleep(1)\n\n# Press Alt+F4 to close\ncomputer.execute_keyboard_hotkey(KeyboardHotkeyAction(keys=[KeyboardKey.ALT, KeyboardKey.F4]))\nprint(\"Closed editor\")\n</code></pre>"},{"location":"tutorials/getting-started/basic-automation/#next-steps","title":"Next Steps","text":"<p>Now that you've created a basic automation script, you can:</p> <ol> <li>Modify it to work with different applications</li> <li>Add error handling for more robustness</li> <li>Create more complex automation sequences</li> <li>Try using different computer implementations (e.g., Docker or cloud-based)</li> </ol> <p>Check out the Advanced Automation Tutorial for more complex examples. </p>"},{"location":"tutorials/getting-started/local-computer-control/","title":"Local Computer Control","text":"<p>This guide explains how to use CommandLAB to control your local computer, including mouse and keyboard automation, taking screenshots, and executing system commands.</p>"},{"location":"tutorials/getting-started/local-computer-control/#introduction","title":"Introduction","text":"<p>CommandLAB provides several implementations for controlling your local computer:</p> <ul> <li><code>LocalPynputComputer</code>: Uses the pynput library for precise control</li> <li><code>LocalPyAutoGUIComputer</code>: Uses the PyAutoGUI library for cross-platform compatibility</li> </ul> <p>These implementations allow you to:</p> <ul> <li>Take screenshots</li> <li>Control the mouse (move, click, scroll)</li> <li>Control the keyboard (press keys, type text)</li> <li>Execute system commands</li> </ul>"},{"location":"tutorials/getting-started/local-computer-control/#installation","title":"Installation","text":"<p>To use local computer control, install CommandLAB with the local extra:</p> <pre><code>pip install \"commandlab[local]\"\n</code></pre> <p>This will install the necessary dependencies, including pynput, PyAutoGUI, and mss.</p>"},{"location":"tutorials/getting-started/local-computer-control/#platform-specific-requirements","title":"Platform-Specific Requirements","text":"<p>Windows: - No additional requirements</p> <p>macOS: - You may need to grant accessibility permissions to your terminal or Python application - Go to System Preferences &gt; Security &amp; Privacy &gt; Privacy &gt; Accessibility and add your terminal application</p> <p>Linux: - X11 is required for input control - Install X11 dependencies: <code>sudo apt-get install python3-xlib python3-tk python3-dev</code></p>"},{"location":"tutorials/getting-started/local-computer-control/#basic-usage","title":"Basic Usage","text":""},{"location":"tutorials/getting-started/local-computer-control/#creating-a-computer-instance","title":"Creating a Computer Instance","text":"<pre><code>from commandLAB.computers.local_pynput_computer import LocalPynputComputer\n\n# Create a computer instance\ncomputer = LocalPynputComputer()\n\n# Always clean up when done\ntry:\n    # Your automation code here\n    pass\nfinally:\n    computer.close()\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#taking-screenshots","title":"Taking Screenshots","text":"<pre><code># Take a screenshot\nscreenshot = computer.get_screenshot()\n\n# The screenshot is returned as a base64-encoded string\nprint(f\"Screenshot size: {len(screenshot.screenshot)} bytes\")\n\n# You can convert it to a PIL Image\nfrom commandLAB.utils.image import b64ToImage\nimage = b64ToImage(screenshot.screenshot)\nprint(f\"Image dimensions: {image.size}\")\n\n# Or save it to a file\nimage.save(\"screenshot.png\")\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#mouse-control","title":"Mouse Control","text":"<pre><code>from commandLAB.types import (\n    ClickAction,\n    DoubleClickAction,\n    DragAction,\n    MouseMoveAction,\n    MouseScrollAction,\n    MouseButton,\n    MouseButtonDownAction,\n    MouseButtonUpAction\n)\n\n# Move the mouse\ncomputer.execute_mouse_move(MouseMoveAction(\n    x=100,\n    y=100,\n    move_duration=0.5  # Duration of the move in seconds\n))\n\n# Click\ncomputer.execute_click(ClickAction(\n    x=100,\n    y=100,\n    button=MouseButton.LEFT,\n    move_duration=0.5,  # Duration of the move to the position\n    press_duration=0.1  # Duration to hold the button down\n))\n\n# Double-click\ncomputer.execute_double_click(DoubleClickAction(\n    x=100,\n    y=100,\n    button=MouseButton.LEFT,\n    double_click_interval_seconds=0.1  # Interval between clicks\n))\n\n# Drag\ncomputer.execute_drag(DragAction(\n    start_x=100,\n    start_y=100,\n    end_x=200,\n    end_y=200,\n    button=MouseButton.LEFT,\n    move_duration=0.5\n))\n\n# Scroll\ncomputer.execute_mouse_scroll(MouseScrollAction(\n    amount=10  # Positive for up, negative for down\n))\n\n# Advanced: Manual button control\ncomputer.execute_mouse_button_down(MouseButtonDownAction(\n    button=MouseButton.LEFT\n))\ncomputer.execute_mouse_button_up(MouseButtonUpAction(\n    button=MouseButton.LEFT\n))\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#keyboard-control","title":"Keyboard Control","text":"<pre><code>from commandLAB.types import (\n    TypeAction,\n    KeyboardHotkeyAction,\n    KeyboardKeyPressAction,\n    KeyboardKeyDownAction,\n    KeyboardKeyReleaseAction,\n    KeyboardKey\n)\n\n# Type text\ncomputer.execute_type(TypeAction(\n    text=\"Hello, CommandLAB!\"\n))\n\n# Press a key\ncomputer.execute_keyboard_key_press(KeyboardKeyPressAction(\n    key=KeyboardKey.ENTER,\n    duration=0.1  # Duration to hold the key down\n))\n\n# Press a keyboard shortcut\ncomputer.execute_keyboard_hotkey(KeyboardHotkeyAction(\n    keys=[KeyboardKey.CTRL, KeyboardKey.C]  # Ctrl+C (copy)\n))\n\n# Advanced: Manual key control\ncomputer.execute_keyboard_key_down(KeyboardKeyDownAction(\n    key=KeyboardKey.SHIFT\n))\ncomputer.execute_keyboard_key_release(KeyboardKeyReleaseAction(\n    key=KeyboardKey.SHIFT\n))\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#executing-system-commands","title":"Executing System Commands","text":"<pre><code>from commandLAB.types import CommandAction\n\n# Execute a system command\nresult = computer.execute_command(CommandAction(\n    command=\"echo Hello, CommandLAB!\",\n    timeout=5  # Timeout in seconds (None for no timeout)\n))\n\nif result:\n    print(\"Command executed successfully\")\nelse:\n    print(\"Command failed\")\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tutorials/getting-started/local-computer-control/#getting-mouse-and-keyboard-state","title":"Getting Mouse and Keyboard State","text":"<pre><code># Get mouse state\nmouse_state = computer.get_mouse_state()\nprint(f\"Mouse position: {mouse_state.position}\")\nprint(f\"Mouse buttons: {mouse_state.buttons}\")\n\n# Get keyboard state\nkeyboard_state = computer.get_keyboard_state()\nprint(f\"Shift key pressed: {keyboard_state.keys.get(KeyboardKey.SHIFT, False)}\")\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#using-pyautogui-instead-of-pynput","title":"Using PyAutoGUI Instead of Pynput","text":"<pre><code>from commandLAB.computers.local_pyautogui_computer import LocalPyAutoGUIComputer\n\n# Create a PyAutoGUI computer instance\ncomputer = LocalPyAutoGUIComputer()\n\n# Use the same API as with pynput\ncomputer.execute_click(ClickAction(x=100, y=100))\ncomputer.execute_type(TypeAction(text=\"Hello, CommandLAB!\"))\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#handling-errors","title":"Handling Errors","text":"<pre><code>try:\n    computer.execute_click(ClickAction(x=100, y=100))\nexcept Exception as e:\n    print(f\"Error executing click: {e}\")\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#common-tasks","title":"Common Tasks","text":""},{"location":"tutorials/getting-started/local-computer-control/#opening-an-application","title":"Opening an Application","text":"<pre><code>from commandLAB.types import CommandAction\n\n# Windows\ncomputer.execute_command(CommandAction(command=\"start notepad\"))\n\n# macOS\ncomputer.execute_command(CommandAction(command=\"open -a TextEdit\"))\n\n# Linux\ncomputer.execute_command(CommandAction(command=\"gedit\"))\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#taking-a-screenshot-and-saving-it","title":"Taking a Screenshot and Saving It","text":"<pre><code>import time\nfrom datetime import datetime\nfrom commandLAB.utils.image import b64ToImage\n\n# Take a screenshot\nscreenshot = computer.get_screenshot()\n\n# Convert to PIL Image\nimage = b64ToImage(screenshot.screenshot)\n\n# Save with timestamp\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nimage.save(f\"screenshot_{timestamp}.png\")\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#automating-a-web-browser","title":"Automating a Web Browser","text":"<pre><code>import time\nfrom commandLAB.types import (\n    CommandAction,\n    TypeAction,\n    KeyboardKeyPressAction,\n    KeyboardKey\n)\n\n# Open Chrome\ncomputer.execute_command(CommandAction(command=\"start chrome\"))\ntime.sleep(2)  # Wait for the browser to open\n\n# Navigate to a website\ncomputer.execute_type(TypeAction(text=\"https://www.google.com\"))\ncomputer.execute_keyboard_key_press(KeyboardKeyPressAction(key=KeyboardKey.ENTER))\ntime.sleep(2)  # Wait for the page to load\n\n# Search for something\ncomputer.execute_type(TypeAction(text=\"CommandLAB python automation\"))\ncomputer.execute_keyboard_key_press(KeyboardKeyPressAction(key=KeyboardKey.ENTER))\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#automating-a-text-editor","title":"Automating a Text Editor","text":"<pre><code>import time\nfrom commandLAB.types import (\n    CommandAction,\n    TypeAction,\n    KeyboardHotkeyAction,\n    KeyboardKey,\n    KeyboardKeyPressAction\n)\n\n# Open Notepad\ncomputer.execute_command(CommandAction(command=\"start notepad\"))\ntime.sleep(1)  # Wait for Notepad to open\n\n# Type some text\ncomputer.execute_type(TypeAction(text=\"Hello, CommandLAB!\\n\\nThis is an automated test.\"))\n\n# Save the file\ncomputer.execute_keyboard_hotkey(KeyboardHotkeyAction(keys=[KeyboardKey.CTRL, KeyboardKey.S]))\ntime.sleep(1)  # Wait for the save dialog\n\n# Type the filename\ncomputer.execute_type(TypeAction(text=\"commandlab_test.txt\"))\ncomputer.execute_keyboard_key_press(KeyboardKeyPressAction(key=KeyboardKey.ENTER))\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/getting-started/local-computer-control/#adding-delays","title":"Adding Delays","text":"<p>When automating UI interactions, it's important to add delays to account for application response times:</p> <pre><code>import time\n\n# Click a button\ncomputer.execute_click(ClickAction(x=100, y=100))\ntime.sleep(0.5)  # Wait for the click to register\n\n# Type text\ncomputer.execute_type(TypeAction(text=\"Hello\"))\ntime.sleep(0.2)  # Wait for the text to appear\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#error-handling","title":"Error Handling","text":"<p>Always include error handling to make your automation robust:</p> <pre><code>try:\n    # Take a screenshot\n    screenshot = computer.get_screenshot()\n\n    # Process the screenshot\n    # ...\n\nexcept Exception as e:\n    print(f\"Error: {e}\")\n    # Handle the error or retry\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#resource-cleanup","title":"Resource Cleanup","text":"<p>Always clean up resources when you're done:</p> <pre><code>computer = LocalPynputComputer()\ntry:\n    # Your automation code here\n    pass\nfinally:\n    computer.close()\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#cross-platform-compatibility","title":"Cross-Platform Compatibility","text":"<p>For cross-platform compatibility, use platform-specific commands:</p> <pre><code>import platform\n\nif platform.system() == \"Windows\":\n    computer.execute_command(CommandAction(command=\"start notepad\"))\nelif platform.system() == \"Darwin\":  # macOS\n    computer.execute_command(CommandAction(command=\"open -a TextEdit\"))\nelse:  # Linux\n    computer.execute_command(CommandAction(command=\"gedit\"))\n</code></pre>"},{"location":"tutorials/getting-started/local-computer-control/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/getting-started/local-computer-control/#permission-issues","title":"Permission Issues","text":"<p>Problem: <code>PermissionError</code> when trying to control mouse or keyboard</p> <p>Solution: - Run your script with administrator/root privileges - On macOS, grant accessibility permissions to your terminal - On Linux, ensure you have the necessary X11 permissions</p>"},{"location":"tutorials/getting-started/local-computer-control/#coordinates-issues","title":"Coordinates Issues","text":"<p>Problem: Clicks are not happening at the expected coordinates</p> <p>Solution: - Check if you have multiple monitors and adjust coordinates accordingly - Use <code>get_screenshot()</code> to verify the screen dimensions - Add debugging to print the actual mouse position using <code>get_mouse_state()</code></p>"},{"location":"tutorials/getting-started/local-computer-control/#timing-issues","title":"Timing Issues","text":"<p>Problem: Actions are happening too quickly or too slowly</p> <p>Solution: - Adjust <code>move_duration</code> and <code>press_duration</code> parameters - Add <code>time.sleep()</code> calls between actions - Use <code>get_mouse_state()</code> and <code>get_keyboard_state()</code> to verify the current state</p>"},{"location":"tutorials/getting-started/local-computer-control/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Remote Computer Control</li> <li>Explore Vision-Language Models for intelligent automation</li> <li>Try the Basic Automation Tutorial </li> </ul>"},{"location":"tutorials/getting-started/remote-control/","title":"Remote Control Tutorial","text":"<p>This tutorial will guide you through the process of setting up and using CommandLAB's remote control capabilities. You'll learn how to control a computer remotely using the daemon.</p>"},{"location":"tutorials/getting-started/remote-control/#introduction","title":"Introduction","text":"<p>CommandLAB's remote control feature allows you to control one computer from another. This is useful for:</p> <ul> <li>Automating tasks on remote servers</li> <li>Controlling headless machines</li> <li>Setting up distributed automation systems</li> <li>Testing applications across different environments</li> </ul>"},{"location":"tutorials/getting-started/remote-control/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>CommandLAB installed on both the controller and target machines</li> <li>Network connectivity between the machines</li> <li>Appropriate permissions to run the daemon on the target machine</li> </ul>"},{"location":"tutorials/getting-started/remote-control/#installation","title":"Installation","text":"<p>On both machines, install CommandLAB with daemon support:</p> <pre><code>pip install \"commandlab[daemon]\"\n</code></pre>"},{"location":"tutorials/getting-started/remote-control/#step-1-start-the-daemon-on-the-target-machine","title":"Step 1: Start the Daemon on the Target Machine","text":"<p>The first step is to start the daemon on the target machine (the one you want to control).</p> <pre><code>python -m commandLAB.daemon.cli start --port 8000 --backend pynput\n</code></pre> <p>This will start the daemon on port 8000 using the pynput backend for computer control. The daemon will print an API token that looks something like this:</p> <pre><code>Starting daemon on port 8000\nAPI Token: abcdef1234567890abcdef1234567890\n</code></pre> <p>Make note of this token, as you'll need it to authenticate with the daemon.</p>"},{"location":"tutorials/getting-started/remote-control/#step-2-connect-to-the-daemon-from-the-controller-machine","title":"Step 2: Connect to the Daemon from the Controller Machine","text":"<p>Now, on the controller machine, you can connect to the daemon using the <code>DaemonClientComputer</code> class:</p> <pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.types import TypeAction, ClickAction, KeyboardHotkeyAction, KeyboardKey\n\n# Connect to the daemon\ncomputer = DaemonClientComputer(\n    daemon_base_url=\"http://target-machine-ip\",  # Replace with the actual IP address\n    daemon_port=8000,\n    provisioning_method=ProvisioningMethod.MANUAL\n)\n\n# Now you can control the target machine\n</code></pre>"},{"location":"tutorials/getting-started/remote-control/#step-3-basic-remote-control-operations","title":"Step 3: Basic Remote Control Operations","text":"<p>Once connected, you can control the target machine using the same API as local control:</p> <pre><code># Take a screenshot of the remote computer\nscreenshot = computer.get_screenshot()\n\n# Click at coordinates (100, 100) on the remote computer\ncomputer.execute_click(ClickAction(x=100, y=100))\n\n# Type text on the remote computer\ncomputer.execute_type(TypeAction(text=\"Hello from another machine!\"))\n\n# Press keyboard shortcut (Ctrl+S) on the remote computer\ncomputer.execute_keyboard_hotkey(KeyboardHotkeyAction(\n    keys=[KeyboardKey.CTRL, KeyboardKey.S]\n))\n</code></pre>"},{"location":"tutorials/getting-started/remote-control/#step-4-execute-commands-on-the-remote-machine","title":"Step 4: Execute Commands on the Remote Machine","text":"<p>You can also execute system commands on the remote machine:</p> <pre><code>from commandLAB.types import CommandAction\n\n# Execute a command on the remote machine\nresult = computer.execute_command(CommandAction(\n    command=\"ls -la\",\n    timeout=5  # Timeout in seconds\n))\n\nif result:\n    print(\"Command executed successfully\")\nelse:\n    print(\"Command failed\")\n</code></pre>"},{"location":"tutorials/getting-started/remote-control/#step-5-clean-up","title":"Step 5: Clean Up","text":"<p>When you're done, make sure to close the connection:</p> <pre><code># Clean up when done\ncomputer.close()\n</code></pre>"},{"location":"tutorials/getting-started/remote-control/#complete-example-remote-web-automation","title":"Complete Example: Remote Web Automation","text":"<p>Here's a complete example that automates opening a browser and performing a web search on a remote machine:</p> <pre><code>import time\nfrom commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.types import (\n    CommandAction,\n    TypeAction,\n    KeyboardKeyPressAction,\n    KeyboardHotkeyAction,\n    KeyboardKey\n)\n\n# Connect to the daemon\ncomputer = DaemonClientComputer(\n    daemon_base_url=\"http://target-machine-ip\",  # Replace with the actual IP address\n    daemon_port=8000,\n    provisioning_method=ProvisioningMethod.MANUAL\n)\n\ntry:\n    # Open a browser on the remote machine\n    computer.execute_command(CommandAction(command=\"chrome\"))\n    time.sleep(2)  # Wait for the browser to open\n\n    # Type a URL\n    computer.execute_type(TypeAction(text=\"https://www.google.com\"))\n    computer.execute_keyboard_key_press(KeyboardKeyPressAction(key=KeyboardKey.ENTER))\n    time.sleep(2)  # Wait for the page to load\n\n    # Type a search query\n    computer.execute_type(TypeAction(text=\"CommandLAB python automation\"))\n    computer.execute_keyboard_key_press(KeyboardKeyPressAction(key=KeyboardKey.ENTER))\n    time.sleep(2)  # Wait for search results\n\n    # Take a screenshot of the results\n    screenshot = computer.get_screenshot()\n    print(\"Took screenshot of search results\")\n\n    # Close the browser\n    computer.execute_keyboard_hotkey(KeyboardHotkeyAction(keys=[KeyboardKey.ALT, KeyboardKey.F4]))\n\nfinally:\n    # Always clean up\n    computer.close()\n</code></pre>"},{"location":"tutorials/getting-started/remote-control/#advanced-secure-remote-control","title":"Advanced: Secure Remote Control","text":"<p>For production use, you should secure your daemon:</p>"},{"location":"tutorials/getting-started/remote-control/#1-use-https","title":"1. Use HTTPS","text":"<p>Generate a self-signed certificate:</p> <pre><code>openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes\n</code></pre> <p>Start the daemon with HTTPS:</p> <pre><code>python -m commandLAB.daemon.cli start --port 8443 --backend pynput --ssl-cert cert.pem --ssl-key key.pem\n</code></pre> <p>Connect using HTTPS:</p> <pre><code>computer = DaemonClientComputer(\n    daemon_base_url=\"https://target-machine-ip\",\n    daemon_port=8443,\n    provisioning_method=ProvisioningMethod.MANUAL\n)\n</code></pre>"},{"location":"tutorials/getting-started/remote-control/#2-use-a-firewall","title":"2. Use a Firewall","text":"<p>Restrict access to the daemon port using a firewall:</p> <pre><code># On Linux\nsudo ufw allow from trusted-ip-address to any port 8000\n\n# On Windows\nnetsh advfirewall firewall add rule name=\"CommandLAB Daemon\" dir=in action=allow protocol=TCP localport=8000 remoteip=trusted-ip-address\n</code></pre>"},{"location":"tutorials/getting-started/remote-control/#advanced-automatic-provisioning","title":"Advanced: Automatic Provisioning","text":"<p>Instead of manually starting the daemon, you can use provisioners to automatically set up and manage daemon environments:</p>"},{"location":"tutorials/getting-started/remote-control/#docker-provisioning","title":"Docker Provisioning","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\nfrom commandLAB.computers.provisioners.docker_provisioner import DockerPlatform\n\n# Create a computer with Docker provisioning\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.DOCKER,\n    platform=DockerPlatform.LOCAL\n)\n\n# Use the computer\n# ...\n\n# Clean up (stops and removes the container)\ncomputer.close()\n</code></pre>"},{"location":"tutorials/getting-started/remote-control/#cloud-provisioning","title":"Cloud Provisioning","text":"<pre><code>from commandLAB.computers.daemon_client_computer import DaemonClientComputer, ProvisioningMethod\n\n# Create a computer in AWS EC2\ncomputer = DaemonClientComputer(\n    provisioning_method=ProvisioningMethod.AWS,\n    region=\"us-west-2\",\n    instance_type=\"t2.micro\"\n)\n\n# Use the computer\n# ...\n\n# Clean up (terminates the EC2 instance)\ncomputer.close()\n</code></pre>"},{"location":"tutorials/getting-started/remote-control/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/getting-started/remote-control/#connection-issues","title":"Connection Issues","text":"<p>If you're having trouble connecting to the daemon:</p> <ol> <li> <p>Check Network Connectivity: Make sure the machines can communicate    <pre><code>ping target-machine-ip\n</code></pre></p> </li> <li> <p>Check Firewall Settings: Make sure the daemon port is open    <pre><code># On Linux\nsudo ufw status\n\n# On Windows\nnetsh advfirewall firewall show rule name=\"CommandLAB Daemon\"\n</code></pre></p> </li> <li> <p>Check Daemon Status: Make sure the daemon is running    <pre><code># On Linux\nps aux | grep commandLAB.daemon\n\n# On Windows\ntasklist | findstr python\n</code></pre></p> </li> </ol>"},{"location":"tutorials/getting-started/remote-control/#authentication-issues","title":"Authentication Issues","text":"<p>If you're having authentication issues:</p> <ol> <li>Check API Token: Make sure you're using the correct API token</li> <li>Restart the Daemon: Sometimes restarting the daemon can help</li> <li>Check Logs: Look for error messages in the daemon logs</li> </ol>"},{"location":"tutorials/getting-started/remote-control/#exercises","title":"Exercises","text":"<ol> <li>Basic Remote Control: Connect to a remote machine and take a screenshot</li> <li>Remote File Management: Create a script that manages files on a remote machine</li> <li>Multi-Machine Control: Create a script that controls multiple remote machines</li> <li>Secure Daemon: Set up a secure daemon with HTTPS and firewall rules</li> </ol>"},{"location":"tutorials/getting-started/remote-control/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Cloud Containers</li> <li>Try the Training Agents Tutorial</li> <li>Explore Provisioners </li> </ul>"}]}