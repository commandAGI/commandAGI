"""
Type stubs for commandAGI2 computer implementations.

This file provides type hints for all computer implementations without requiring
the actual dependencies to be installed, which is helpful for development environments
and static type checking.
"""

from typing import Dict, List, Optional, Tuple, Union, Any, Literal, IO, AnyStr
import logging
from pathlib import Path

from commandAGI2.computers.base_computer import (
    BaseComputer,
    BaseJupyterNotebook,
    BaseShell,
    BaseComputerFile,
)
from commandAGI2.types import (
    ShellCommandAction,
    KeyboardHotkeyAction,
    KeyboardKey,
    KeyboardKeyDownAction,
    KeyboardKeyPressAction,
    KeyboardKeyReleaseAction,
    KeyboardKeysDownAction,
    KeyboardKeysPressAction,
    KeyboardKeysReleaseAction,
    KeyboardStateObservation,
    MouseButton,
    MouseButtonDownAction,
    MouseButtonUpAction,
    MouseMoveAction,
    MouseScrollAction,
    MouseStateObservation,
    ScreenshotObservation,
    TypeAction,
    ClickAction,
    DoubleClickAction,
    DragAction,
    LayoutTreeObservation,
    ProcessesObservation,
    WindowsObservation,
    DisplaysObservation,
    RunProcessAction,
)

class LocalComputerFile(BaseComputerFile):
    """Implementation of BaseComputerFile for local computer files."""

    def __init__(
        self,
        computer: "BaseComputer",
        path: Union[str, Path],
        mode: str = "r",
        encoding: Optional[str] = None,
        errors: Optional[str] = None,
        buffering: int = -1,
    ) -> None: ...
    def read(self, size: Optional[int] = None) -> AnyStr: ...
    def write(self, data: AnyStr) -> int: ...
    def seek(self, offset: int, whence: int = 0) -> int: ...
    def tell(self) -> int: ...
    def flush(self) -> None: ...
    def close(self) -> None: ...
    def readable(self) -> bool: ...
    def writable(self) -> bool: ...
    def seekable(self) -> bool: ...
    def readline(self, size: int = -1) -> AnyStr: ...
    def readlines(self, hint: int = -1) -> List[AnyStr]: ...
    def writelines(self, lines: List[AnyStr]) -> None: ...
    def __iter__(self) -> "LocalComputerFile": ...
    def __next__(self) -> AnyStr: ...
    def __enter__(self) -> "LocalComputerFile": ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

class E2BDesktopComputerFile(BaseComputerFile):
    """Implementation of BaseComputerFile for E2B Desktop computer files."""

    # Same methods as LocalComputerFile
    pass

class VNCComputerFile(BaseComputerFile):
    """Implementation of BaseComputerFile for VNC computer files."""

    # Same methods as LocalComputerFile
    pass

class PigDevComputerFile(BaseComputerFile):
    """Implementation of BaseComputerFile for PigDev computer files."""

    # Same methods as LocalComputerFile
    pass

class ScrapybaraComputerFile(BaseComputerFile):
    """Implementation of BaseComputerFile for Scrapybara computer files."""

    # Same methods as LocalComputerFile
    pass

class DaemonClientComputerFile(BaseComputerFile):
    """Implementation of BaseComputerFile for Daemon Client computer files."""

    # Same methods as LocalComputerFile
    pass

class NbFormatJupyterNotebook(BaseJupyterNotebook):
    """Implementation of BaseJupyterNotebook using nbformat and nbclient libraries."""

    def create_notebook(self) -> Dict[str, Any]: ...
    def read_notebook(self, path: Union[str, Path]) -> Dict[str, Any]: ...
    def save_notebook(
        self, notebook: Dict[str, Any], path: Optional[Union[str, Path]] = None
    ) -> Path: ...
    def add_markdown_cell(
        self, notebook: Dict[str, Any], source: str, position: Optional[int] = None
    ) -> Dict[str, Any]: ...
    def add_code_cell(
        self, notebook: Dict[str, Any], source: str, position: Optional[int] = None
    ) -> Dict[str, Any]: ...
    def update_cell(
        self, notebook: Dict[str, Any], index: int, source: str
    ) -> Dict[str, Any]: ...
    def remove_cell(self, notebook: Dict[str, Any], index: int) -> Dict[str, Any]: ...
    def list_cells(self, notebook: Dict[str, Any]) -> List[Dict[str, Any]]: ...
    def execute_notebook(
        self, notebook: Dict[str, Any], timeout: int = 600
    ) -> Dict[str, Any]: ...
    def execute_cell(
        self, notebook: Dict[str, Any], index: int, timeout: int = 60
    ) -> Dict[str, Any]: ...
    def get_cell_output(
        self, notebook: Dict[str, Any], index: int
    ) -> List[Dict[str, Any]]: ...
    def clear_cell_output(
        self, notebook: Dict[str, Any], index: int
    ) -> Dict[str, Any]: ...
    def clear_all_outputs(self, notebook: Dict[str, Any]) -> Dict[str, Any]: ...

class LocalShell(BaseShell):
    """Implementation of BaseShell for local system shells."""

    def __init__(
        self,
        executable: str = ...,
        cwd: Optional[Union[str, Path]] = None,
        env: Optional[Dict[str, str]] = None,
        logger: Optional[logging.Logger] = None,
    ) -> None: ...
    def start(self) -> bool: ...
    def stop(self) -> bool: ...
    def execute(
        self, command: str, timeout: Optional[float] = None
    ) -> Dict[str, Any]: ...
    def read_output(self, timeout: Optional[float] = None) -> str: ...
    def send_input(self, text: str) -> bool: ...
    def change_directory(self, path: Union[str, Path]) -> bool: ...
    def set_environment_variable(self, name: str, value: str) -> bool: ...
    def get_environment_variable(self, name: str) -> Optional[str]: ...
    def is_running(self) -> bool: ...
    @property
    def current_directory(self) -> Path: ...

class LocalComputer(BaseComputer):
    """Base class for local computer implementations.

    This class provides common functionality for local computer implementations
    such as screenshot capture, command execution, and basic resource management.
    """

    def __init__(self) -> None: ...
    def _start(self) -> bool: ...
    def _stop(self) -> bool: ...
    def _get_screenshot(
        self, display_id: int = 0, format: Literal["base64", "PIL", "path"] = "PIL"
    ) -> ScreenshotObservation: ...
    def _get_layout_tree(self) -> LayoutTreeObservation: ...
    def _get_windows_layout_tree(self) -> LayoutTreeObservation: ...
    def _get_macos_layout_tree(self) -> LayoutTreeObservation: ...
    def _get_linux_layout_tree(self) -> LayoutTreeObservation: ...
    def _execute_shell_command(self, action: ShellCommandAction): ...
    def _run_process(self, action: RunProcessAction) -> bool: ...
    def _pause(self): ...
    def _resume(self, timeout_hours: Optional[float] = None): ...
    def create_jupyter_notebook(self) -> NbFormatJupyterNotebook: ...
    def start_jupyter_server(
        self, port: int = 8888, notebook_dir: Optional[str] = None
    ) -> bool: ...
    def stop_jupyter_server(self) -> bool: ...
    def create_shell(
        self,
        executable: str = ...,
        cwd: Optional[Union[str, Path]] = None,
        env: Optional[Dict[str, str]] = None,
    ) -> LocalShell: ...
    def _find_free_port(self) -> int: ...
    def _copy_to_computer(self, source_path: Path, destination_path: Path) -> None: ...
    def _copy_from_computer(
        self, source_path: Path, destination_path: Path
    ) -> None: ...
    def _copy_local(self, source_path: Path, destination_path: Path) -> None: ...
    def _get_processes(self) -> ProcessesObservation: ...
    def _get_windows(self) -> WindowsObservation: ...
    def _get_windows_windows(self) -> WindowsObservation: ...
    def _get_windows_macos(self) -> WindowsObservation: ...
    def _get_windows_linux(self) -> WindowsObservation: ...
    def _get_displays(self) -> DisplaysObservation: ...
    def _get_windows_display_info(self, display_info: dict) -> dict: ...
    def _get_macos_display_info(
        self, display_info: dict, display_index: int
    ) -> dict: ...
    def _get_linux_display_info(
        self, display_info: dict, display_index: int
    ) -> dict: ...
    @property
    def video_stream_url(self) -> str: ...
    def start_video_stream(self) -> bool: ...
    def stop_video_stream(self) -> bool: ...
    def _open(
        self,
        path: Union[str, Path],
        mode: str = "r",
        encoding: Optional[str] = None,
        errors: Optional[str] = None,
        buffering: int = -1,
    ) -> LocalComputerFile: ...

# Local PyAutoGUI Computer
class LocalPyAutoGUIComputer(LocalComputer):
    """Local computer implementation using PyAutoGUI for input control."""

    def __init__(self) -> None: ...
    def reset_state(self) -> None: ...
    def _get_mouse_state(self) -> MouseStateObservation: ...
    def _get_keyboard_state(self) -> KeyboardStateObservation: ...
    def _execute_keyboard_key_down(self, action: KeyboardKeyDownAction): ...
    def _execute_keyboard_key_release(self, action: KeyboardKeyReleaseAction): ...
    def _execute_type(self, action: TypeAction): ...
    def _execute_mouse_move(self, action: MouseMoveAction): ...
    def _execute_mouse_scroll(self, action: MouseScrollAction): ...
    def _execute_mouse_button_down(self, action: MouseButtonDownAction): ...
    def _execute_mouse_button_up(self, action: MouseButtonUpAction): ...

# Local Pynput Computer
class LocalPynputComputer(LocalComputer):
    """Local computer implementation using Pynput for input control and state tracking."""

    def __init__(self) -> None: ...
    def _start(self) -> bool: ...
    def _stop(self) -> bool: ...
    def reset_state(self) -> None: ...
    def _on_keyboard_press(self, key: Any) -> None: ...
    def _on_keyboard_release(self, key: Any) -> None: ...
    def _on_mouse_move(self, x: int, y: int) -> None: ...
    def _on_mouse_click(self, x: int, y: int, button: Any, pressed: bool) -> None: ...
    def _on_mouse_scroll(self, x: int, y: int, dx: int, dy: int) -> None: ...
    def _get_mouse_state(self) -> MouseStateObservation: ...
    def _get_keyboard_state(self) -> KeyboardStateObservation: ...
    def get_observation(self) -> Any: ...
    def _execute_keyboard_key_down(self, action: KeyboardKeyDownAction): ...
    def _execute_keyboard_key_release(self, action: KeyboardKeyReleaseAction): ...
    def _execute_type(self, action: TypeAction): ...
    def _execute_mouse_move(self, action: MouseMoveAction): ...
    def _execute_mouse_scroll(self, action: MouseScrollAction): ...
    def _execute_mouse_button_down(self, action: MouseButtonDownAction): ...
    def _execute_mouse_button_up(self, action: MouseButtonUpAction): ...
    def _execute_keyboard_key_press(self, action: KeyboardKeyPressAction): ...
    def _execute_keyboard_hotkey(self, action: KeyboardHotkeyAction): ...

# VNC Computer
class VNCComputer(BaseComputer):
    def __init__(
        self,
        host: str = "localhost",
        port: int = 5900,
        password: Optional[str] = None,
        ssh_host: Optional[str] = None,
        ssh_port: int = 22,
        ssh_username: Optional[str] = None,
        ssh_password: Optional[str] = None,
        ssh_key_path: Optional[str] = None,
    ) -> None: ...
    def _start(self) -> bool: ...
    def _stop(self) -> bool: ...
    def reset_state(self) -> None: ...
    def _get_screenshot(
        self, display_id: int = 0, format: Literal["base64", "PIL", "path"] = "PIL"
    ) -> ScreenshotObservation: ...
    def _get_mouse_state(self) -> MouseStateObservation: ...
    def _get_keyboard_state(self) -> KeyboardStateObservation: ...
    def _execute_shell_command(self, action: ShellCommandAction): ...
    def _execute_keyboard_key_down(self, action: KeyboardKeyDownAction): ...
    def _execute_keyboard_key_release(self, action: KeyboardKeyReleaseAction): ...
    def _execute_type(self, action: TypeAction): ...
    def _execute_mouse_move(self, action: MouseMoveAction): ...
    def _execute_mouse_scroll(self, action: MouseScrollAction): ...
    def _execute_mouse_button_down(self, action: MouseButtonDownAction): ...
    def _execute_mouse_button_up(self, action: MouseButtonUpAction): ...
    def _pause(self): ...
    def _resume(self, timeout_hours: Optional[float] = None): ...
    def _copy_to_computer(self, source_path: Path, destination_path: Path) -> None: ...
    def _copy_from_computer(
        self, source_path: Path, destination_path: Path
    ) -> None: ...
    def _run_process(self, action: RunProcessAction) -> bool: ...
    def create_jupyter_notebook(self) -> BaseJupyterNotebook: ...
    def start_jupyter_server(
        self, port: int = 8888, notebook_dir: Optional[str] = None
    ) -> bool: ...
    def stop_jupyter_server(self) -> bool: ...
    def create_shell(
        self,
        executable: str = ...,
        cwd: Optional[Union[str, Path]] = None,
        env: Optional[Dict[str, str]] = None,
    ) -> BaseShell: ...
    @property
    def video_stream_url(self) -> str: ...
    def start_video_stream(self) -> bool: ...
    def stop_video_stream(self) -> bool: ...
    def _open(
        self,
        path: Union[str, Path],
        mode: str = "r",
        encoding: Optional[str] = None,
        errors: Optional[str] = None,
        buffering: int = -1,
    ) -> VNCComputerFile: ...

# E2B Desktop Computer
class E2BDesktopComputer(BaseComputer):
    def __init__(self, video_stream: bool = False) -> None: ...
    def _start(self) -> bool: ...
    def _stop(self) -> bool: ...
    def reset_state(self) -> None: ...
    def _get_screenshot(
        self, display_id: int = 0, format: Literal["base64", "PIL", "path"] = "PIL"
    ) -> ScreenshotObservation: ...
    def _get_mouse_state(self) -> MouseStateObservation: ...
    def _get_keyboard_state(self) -> KeyboardStateObservation: ...
    def _execute_shell_command(self, action: ShellCommandAction): ...
    def _execute_keyboard_key_down(self, action: KeyboardKeyDownAction): ...
    def _execute_keyboard_key_release(self, action: KeyboardKeyReleaseAction): ...
    def _execute_type(self, action: TypeAction): ...
    def _execute_mouse_move(self, action: MouseMoveAction): ...
    def _execute_mouse_scroll(self, action: MouseScrollAction): ...
    def _execute_mouse_button_down(self, action: MouseButtonDownAction): ...
    def _execute_mouse_button_up(self, action: MouseButtonUpAction): ...
    def _execute_click(self, action: ClickAction): ...
    def _execute_double_click(self, action: DoubleClickAction): ...
    def _execute_keyboard_key_press(self, action: KeyboardKeyPressAction): ...
    def _execute_keyboard_hotkey(self, action: KeyboardHotkeyAction): ...
    def _run_process(self, action: RunProcessAction) -> bool: ...
    def create_jupyter_notebook(self) -> BaseJupyterNotebook: ...
    def start_jupyter_server(
        self, port: int = 8888, notebook_dir: Optional[str] = None
    ) -> bool: ...
    def stop_jupyter_server(self) -> bool: ...
    def create_shell(
        self,
        executable: str = ...,
        cwd: Optional[Union[str, Path]] = None,
        env: Optional[Dict[str, str]] = None,
    ) -> BaseShell: ...
    def locate_on_screen(self, text: str) -> Optional[Tuple[int, int]]: ...
    def open_file(self, file_path: str) -> bool: ...
    def get_video_stream_url(self) -> str: ...
    def _pause(self): ...
    def _resume(self, timeout_hours: Optional[float] = None): ...
    @property
    def video_stream_url(self) -> str: ...
    def start_video_stream(self) -> bool: ...
    def stop_video_stream(self) -> bool: ...
    def _open(
        self,
        path: Union[str, Path],
        mode: str = "r",
        encoding: Optional[str] = None,
        errors: Optional[str] = None,
        buffering: int = -1,
    ) -> E2BDesktopComputerFile: ...

# Daemon Client Computer
class DaemonClientComputer(BaseComputer):
    def __init__(
        self,
        daemon_base_url: str,
        daemon_port: int,
        daemon_token: str,
        provisioner: Any,
    ) -> None: ...
    def _start(self) -> bool: ...
    def _stop(self) -> bool: ...
    def reset_state(self) -> bool: ...
    def get_observation(self) -> Dict[str, Any]: ...
    def _get_screenshot(
        self, display_id: int = 0, format: Literal["base64", "PIL", "path"] = "PIL"
    ) -> ScreenshotObservation: ...
    def _get_mouse_state(self) -> MouseStateObservation: ...
    def _get_keyboard_state(self) -> KeyboardStateObservation: ...
    def _execute_shell_command(self, action: ShellCommandAction): ...
    def _execute_keyboard_key_down(self, action: KeyboardKeyDownAction): ...
    def _execute_keyboard_key_release(self, action: KeyboardKeyReleaseAction): ...
    def _execute_keyboard_key_press(self, action: KeyboardKeyPressAction): ...
    def _execute_keyboard_hotkey(self, action: KeyboardHotkeyAction): ...
    def _execute_type(self, action: TypeAction): ...
    def _execute_mouse_move(self, action: MouseMoveAction): ...
    def _execute_mouse_scroll(self, action: MouseScrollAction): ...
    def _execute_mouse_button_down(self, action: MouseButtonDownAction): ...
    def _execute_mouse_button_up(self, action: MouseButtonUpAction): ...
    def _run_process(self, action: RunProcessAction) -> bool: ...
    def create_jupyter_notebook(self) -> BaseJupyterNotebook: ...
    def start_jupyter_server(
        self, port: int = 8888, notebook_dir: Optional[str] = None
    ) -> bool: ...
    def stop_jupyter_server(self) -> bool: ...
    def create_shell(
        self,
        executable: str = ...,
        cwd: Optional[Union[str, Path]] = None,
        env: Optional[Dict[str, str]] = None,
    ) -> BaseShell: ...
    def _pause(self): ...
    def _resume(self, timeout_hours: Optional[float] = None): ...
    @property
    def video_stream_url(self) -> str: ...
    def start_video_stream(self) -> bool: ...
    def stop_video_stream(self) -> bool: ...
    def _open(
        self,
        path: Union[str, Path],
        mode: str = "r",
        encoding: Optional[str] = None,
        errors: Optional[str] = None,
        buffering: int = -1,
    ) -> DaemonClientComputerFile: ...

# PigDev Computer
class PigDevComputer(BaseComputer):
    def __init__(
        self, api_key: Optional[str] = None, machine_id: Optional[str] = None
    ) -> None: ...
    def _start(self) -> bool: ...
    def _stop(self) -> bool: ...
    def reset_state(self) -> None: ...
    def _get_screenshot(
        self, display_id: int = 0, format: Literal["base64", "PIL", "path"] = "PIL"
    ) -> ScreenshotObservation: ...
    def _get_mouse_state(self) -> MouseStateObservation: ...
    def _get_keyboard_state(self) -> KeyboardStateObservation: ...
    def _execute_shell_command(self, action: ShellCommandAction): ...
    def _execute_keyboard_key_down(self, action: KeyboardKeyDownAction): ...
    def _execute_keyboard_key_release(self, action: KeyboardKeyReleaseAction): ...
    def _execute_type(self, action: TypeAction): ...
    def _execute_mouse_move(self, action: MouseMoveAction): ...
    def _execute_mouse_scroll(self, action: MouseScrollAction): ...
    def _execute_mouse_button_down(self, action: MouseButtonDownAction): ...
    def _execute_mouse_button_up(self, action: MouseButtonUpAction): ...
    def _execute_click(self, action: ClickAction): ...
    def _execute_double_click(self, action: DoubleClickAction): ...
    def _execute_drag(self, action: DragAction): ...
    def _execute_keyboard_key_press(self, action: KeyboardKeyPressAction): ...
    def _execute_keyboard_hotkey(self, action: KeyboardHotkeyAction): ...
    def _run_process(self, action: RunProcessAction) -> bool: ...
    def create_jupyter_notebook(self) -> BaseJupyterNotebook: ...
    def start_jupyter_server(
        self, port: int = 8888, notebook_dir: Optional[str] = None
    ) -> bool: ...
    def stop_jupyter_server(self) -> bool: ...
    def create_shell(
        self,
        executable: str = ...,
        cwd: Optional[Union[str, Path]] = None,
        env: Optional[Dict[str, str]] = None,
    ) -> BaseShell: ...
    def _pause(self): ...
    def _resume(self, timeout_hours: Optional[float] = None): ...
    @property
    def video_stream_url(self) -> str: ...
    def start_video_stream(self) -> bool: ...
    def stop_video_stream(self) -> bool: ...
    def _open(
        self,
        path: Union[str, Path],
        mode: str = "r",
        encoding: Optional[str] = None,
        errors: Optional[str] = None,
        buffering: int = -1,
    ) -> PigDevComputerFile: ...

# Scrapybara Computer
class ScrapybaraComputer(BaseComputer):
    def __init__(self, api_key: Optional[str] = None) -> None: ...
    def _start(self) -> bool: ...
    def _stop(self) -> bool: ...
    def reset_state(self) -> None: ...
    def _get_screenshot(
        self, display_id: int = 0, format: Literal["base64", "PIL", "path"] = "PIL"
    ) -> ScreenshotObservation: ...
    def _get_mouse_state(self) -> MouseStateObservation: ...
    def _get_keyboard_state(self) -> KeyboardStateObservation: ...
    def _execute_shell_command(self, action: ShellCommandAction): ...
    def _execute_keyboard_key_down(self, action: KeyboardKeyDownAction): ...
    def _execute_keyboard_key_release(self, action: KeyboardKeyReleaseAction): ...
    def _execute_type(self, action: TypeAction): ...
    def _execute_mouse_move(self, action: MouseMoveAction): ...
    def _execute_mouse_scroll(self, action: MouseScrollAction): ...
    def _execute_mouse_button_down(self, action: MouseButtonDownAction): ...
    def _execute_mouse_button_up(self, action: MouseButtonUpAction): ...
    def _execute_click(self, action: ClickAction): ...
    def _execute_keyboard_key_press(self, action: KeyboardKeyPressAction): ...
    def _execute_keyboard_hotkey(self, action: KeyboardHotkeyAction): ...
    def _execute_double_click(self, action: DoubleClickAction): ...
    def _execute_drag(self, action: DragAction): ...
    def _run_process(self, action: RunProcessAction) -> bool: ...
    def create_jupyter_notebook(self) -> BaseJupyterNotebook: ...
    def start_jupyter_server(
        self, port: int = 8888, notebook_dir: Optional[str] = None
    ) -> bool: ...
    def stop_jupyter_server(self) -> bool: ...
    def create_shell(
        self,
        executable: str = ...,
        cwd: Optional[Union[str, Path]] = None,
        env: Optional[Dict[str, str]] = None,
    ) -> BaseShell: ...
    def _pause(self): ...
    def _resume(self, timeout_hours: Optional[float] = None): ...
    def get_stream_url(self) -> str: ...
    @property
    def video_stream_url(self) -> str: ...
    def start_video_stream(self) -> bool: ...
    def stop_video_stream(self) -> bool: ...
    def _open(
        self,
        path: Union[str, Path],
        mode: str = "r",
        encoding: Optional[str] = None,
        errors: Optional[str] = None,
        buffering: int = -1,
    ) -> ScrapybaraComputerFile: ...

class UbuntuScrapybaraComputer(ScrapybaraComputer):
    def __init__(self, api_key: Optional[str] = None) -> None: ...
    def _start(self) -> bool: ...
    def _execute_shell_command(self, action: ShellCommandAction): ...
    def edit_file(self, path: str, command: str, **kwargs) -> bool: ...

class BrowserScrapybaraComputer(ScrapybaraComputer):
    def __init__(self, api_key: Optional[str] = None) -> None: ...
    def _start(self) -> bool: ...
    def get_cdp_url(self) -> str: ...
    def save_auth(self, name: str = "default") -> str: ...
    def authenticate(self, auth_state_id: str) -> bool: ...
    def _execute_shell_command(self, action: ShellCommandAction): ...

class WindowsScrapybaraComputer(ScrapybaraComputer):
    def __init__(self, api_key: Optional[str] = None) -> None: ...
    def _start(self) -> bool: ...
    def _execute_shell_command(self, action: ShellCommandAction): ...
